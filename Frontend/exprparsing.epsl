%import epslfiles;
%import tokenizer;
%import epslctx;
%import parsing;
%import types_;
%import exprs;

BiOperator {
    [Byte]:spelling,
    Bool:cond_eval
}

BiOperatorLevel {
    [BiOperator]:operators,
}

%global [BiOperatorLevel]?:bioperator_levels_cache;

[BiOperatorLevel]#get bioperator levels {
    given bioperator_levels_cache as [BiOperatorLevel]:bioperator_levels {
        return bioperator_levels;
    };
    [BiOperatorLevel]:bioperator_levels = [BiOperatorLevel] [
        BiOperatorLevel [[BiOperator] [
            BiOperator ["=", false], BiOperator ["+=", false],
            BiOperator ["-=", false], BiOperator ["*=", false],
            BiOperator ["/=", false], BiOperator ["%=", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["&&", true], BiOperator ["||", true]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator [">", false], BiOperator ["<", false],
            BiOperator [">=", false], BiOperator ["<=", false],
            BiOperator ["==", false], BiOperator ["!=", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["+", false], BiOperator ["-", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["*", false], BiOperator ["/", false],
            BiOperator ["~/", false], BiOperator ["%", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["**", false]
        ]],
    ];
    bioperator_levels_cache = bioperator_levels;
    return bioperator_levels;
}

$Expression?#parse expr term inner [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].require_more why: ["Expected expression"] {
        return null;
    };

    W:start = [state].cur_start;
    [state].consume;

    // STEP: check for function calls

    // STEP: check for constants
    if [state].last_id == T_INT {
        Z64:val = [[state].last_data#IntTokenData?].unwrap.val;
        $NumericType_:type_ = ZType_ [64];
        if val > 0 {
            if val > ~[0#W32]#Z64 {
                type_ = WType_ [64];
            } else {
                type_ = WType_ [32];
            };
        } else {
            if val > -[1#Z64] << [31] {
                type_ = ZType_ [32];
            };
        };
        return IntConstantExpression [
            start, [state].last_end, type_, val
        ];
    } elif [state].last_id == T_FLOAT {
        R:val = [[state].last_data#FloatTokenData?].unwrap.val;
        return FloatConstantExpression [
            start, [state].last_end, RType_ [64], val
        ];
    } elif [state].last_id == T_BYTE {
        Byte:val = [[state].last_data#ByteTokenData?].unwrap.val;
        return ByteConstantExpression [
            start, [state].last_end, ByteType_ [8], val
        ];
    } elif [state].last_id == T_STR {
        Str:val = [[state].last_data#StrTokenData?].unwrap.val;
        return StrConstantExpression [
            start, [state].last_end, Str_, val
        ];

    // STEP: check for prefix operators
    } elif [state].last_id == '-' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            Str:template = "'-' expects a number, found {}";
            if !expect [operand] satisfies [NumericType_Criteria []] state: [state] template: [template] {
                return null;
            };
            $Type_:type_ = operand.type_;
            given type_ as $UnsignedIntegerType_:uint_type_ {
                type_ = ZType_ [uint_type_.bits];
            };
            given operand as IntConstantExpression:int_const {
                int_const.type_ = type_;
                int_const.val *= -1;
                int_const.start_index = start;
                return int_const;
            } given operand as FloatConstantExpression:float_const {
                float_const.val *= -1;
                float_const.start_index = start;
                return float_const;
            };
            return NegateExpression [
                start, [state].last_end, type_, operand
            ];
        } else {
            return null;
        };
    } elif [state].last_id == '!' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            return NotExpression [
                start, [state].last_end, BoolType_ [1], operand
            ];
        } else {
            return null;
        };

    // STEP: check for parenthesis groups
    } elif [state].last_id == T_PAREN_GROUP {
        given parse expr [[state].last_substate] ctx: [ctx] as $Expression:inner {
            return ParenExpression [start, [state].last_end, inner.type_, inner];
        } else {
            return null;
        };

    // STEP: check for exprs starting with an identifier
    } elif [state].last_id == T_IDENT {
        Str:ident = [[state].last_data].read_identifier;
        return parse ident [ident] expr [state] ctx: [ctx];
    };

    [state].unconsume;
    [state].error_about_current msg: ["Expected expression"];
    return null;
}

VariableDeclarationExpression?#parse var decl ident: [Str:ident] state: [ParseState:state] ctx: [ExprContext:ctx] {
    // this function is to be called when a var decl has been detected,
    // but the ':' has not been consumed

    W:start = [state].last_start;
    [state].consume; // eat the ':'

    $Type_?:maybe_type_ = null;
    if [state].cur_id != '=' {
        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:type_ {
            maybe_type_ = type_;
        } else {
            return null;
        };
    };
    if ![state].consume['='] {
        return null;
    };

    $Expression?:maybe_initializer = null;

    given parse expr [state] ctx: [ctx] as $Expression:initializer {
        maybe_initializer = initializer;
        given maybe_type_ as $Type_:var_type_ {
            if ![initializer.type_] is convertible to [var_type_] {
                Str:msg = "Cannot assign value of type {} to variable wit type {}"
                    % [initializer.type_].stringify % [var_type_].stringify;
                [state].error_at[initializer] msg: [msg];
            };
        } else {
            given initializer.type_ as NullType_:null_type_ {
                [state].error_at[initializer]
                    msg: ["Variable type cannot be inferred to initializer type Null"];
            };
            maybe_type_ = initializer.type_;
        };
    };

    given maybe_type_ as $Type_:var_type_ {
        ScopeVar:var = add var [ident] type_: [[maybe_type_].unwrap] to: [ctx];
        given maybe_initializer as $Expression:initializer {
            return VariableDeclarationExpression [
                start, [state].last_end, NullType_ [], var, initializer
            ];
        };
    };

    return null;
}

WhileExpression?#parse while_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    ExprContext:cond_ctx = [ctx].new_scope;
    $Expression?:maybe_cond = parse expr [state] ctx: [cond_ctx];
    if !maybe_cond {
        return null;
    };
    $Expression:cond = [maybe_cond].unwrap;

    ExprContext:block_ctx = [ctx].new_scope;
    LoopCtx:loop_ctx = LoopCtx [
        [BreakExpression] [], [ContinueExpression] []
    ];
    block_ctx.loop_ctx = loop_ctx;
    Block?:maybe_block = parse block [state] ctx: [block_ctx];
    if !maybe_block {
        return null;
    };
    Block:block = [maybe_block].unwrap;

    $Type_?:maybe_base_type_ = null;

    Block?:maybe_else_block = null;
    if [[state].try_read_ident] equals ["else"#Str?] {
        [state].consume;
        given parse block [state] ctx: [ctx] as Block:else_block {
            maybe_else_block = else_block;
            maybe_base_type_ = else_block.type_;
        } else {
            return null;
        };
    };

    given cond as $ConstantExpression:const_expr {
        if [const_expr].is_truthy {
            maybe_base_type_ = NeverType_ [];
        };
    };

    $Type_:type_ = NullType_ [];
    given maybe_base_type_ as $Type_:base_type_ {
        type_ = base_type_;
        for BreakExpression:break_ in loop_ctx.breaks {
            given common type_ between [type_] and [break_.result.type_]
            as $Type_:common_type_ {
                type_ = common_type_;
            } else {
                type_ = NullType_ [];
                break;
            };
        };
    };

    return WhileExpression [
        start, [state].last_end, type_,
        cond, cond_ctx.scope,
        block, maybe_else_block
    ];
}

IfExpression?#parse if_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    [IfBranch]:branches = [IfBranch] [];

    $Type_?:maybe_type_ = NeverType_ [];

    Bool:has_else = false;
    while true {
        ExprContext:cond_ctx = [ctx].new_scope;
        $Expression?:maybe_cond = parse expr [state] ctx: [cond_ctx];
        if !maybe_cond {
            return null;
        };
        $Expression:cond = [maybe_cond].unwrap;

        ctx = [cond_ctx].new_scope;
        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [block.type_];
        };

        [branches].append[IfBranch [cond, cond_ctx.scope, block]];

        Str?:next_ident = [state].try_read_ident;

        if [next_ident] equals ["elif"#Str?] {
            [state].consume;
            continue;
        } elif [next_ident] equals ["else"#Str?] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Block?:maybe_else_block = null;
    if has_else {
        ctx = [ctx].new_scope;
        maybe_else_block = parse block [state] ctx: [ctx];
        if !maybe_else_block {
            return null;
        };
        Block:else_block = [maybe_else_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [else_block.type_];
        };
    } else {
        maybe_type_ = null;
    };

    $Type_:type_ = [maybe_type_] || [NullType_ []];

    return IfExpression [
        start, [state].last_end, type_, branches, maybe_else_block
    ];
}

SubVarDeclNode?#parse explicit var decl [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].cur_start;

    if ![state].consume[T_IDENT] name: ["variable name"] {
        return null;
    };
    Str:var_ident = [[state].last_data].read_identifier;

    if ![state].consume[':'] {
        return null;
    };

    $Type_?:maybe_type_ = parse type_ state: [state]
        ctx: [ctx.mod_ctx.type__ctx];
    if !maybe_type_ {
        return null;
    };
    $Type_:type_ = [maybe_type_].unwrap;

    return SubVarDeclNode [
        start, [state].last_end, add var [var_ident] type_: [type_] to: [ctx]
    ];
}

GivenExpression?#parse given_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    $Expression?:maybe_scrutinee = parse expr [state] ctx: [ctx];
    if !maybe_scrutinee {
        return null;
    };
    $Expression:scrutinee = [maybe_scrutinee].unwrap;

    [GivenArm]:arms = [GivenArm] [];

    $Type_?:maybe_result_type_ = NeverType_ [];

    if [[state].try_read_ident] not equals ["as"#Str?] {
        [state].error_at_current msg: ["Expected 'as'"];
        return null;
    };

    Bool:has_else = false;

    while true {
        [state].consume; // eat the 'as'

        ctx = [ctx].new_scope;

        SubVarDeclNode?:maybe_var_decl = parse explicit var decl [state] ctx: [ctx];
        if !maybe_var_decl {
            return null;
        };
        SubVarDeclNode:var_decl = [maybe_var_decl].unwrap;

        $Type_:var_type_ = var_decl.var.type_;
        if ![scrutinee.type_] is castable to [OptionalType_ [var_type_]] {
            Str:msg = "Scrutinee of type {} can never be {}"
                % [scrutinee.type_].stringify % [var_type_].stringify;
            [state].error_at[var_decl] msg: [msg];
        };

        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_result_type_ as $Type_:result_so_far {
            maybe_result_type_= common type_ between
                [result_so_far] and [block.type_];
        };

        [arms].append[GivenArm [var_decl.var, block]];

        Str?:ident = [state].try_read_ident;
        if [ident] equals ["as"#Str?] {
            continue;
        } elif [ident] equals ["else"#Str?] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Bool:else_never = false;
    Block?:maybe_else_block = null;

    if has_else {
        if [[state].try_read_ident] equals ["never"#Str?] {
            [state].consume;
            else_never = true;
        } else {
            maybe_else_block = parse block [state] ctx: [ctx];
            if !maybe_else_block {
                return null;
            };
            Block:else_block = [maybe_else_block].unwrap;

            given maybe_result_type_ as $Type_:result_so_far {
                maybe_result_type_= common type_ between
                    [result_so_far] and [else_block.type_];
            };
        };
    } else {
        maybe_result_type_ = null;
    };

    if else_never {
        [$Type_]:arm_types_ = [$Type_] [];
        for GivenArm:arm in arms {
            [arm_types_].append[arm.var.type_];
        };
        if !types_ [arm_types_] encompass [scrutinee.type_] {
            Str:msg = "Given arms possibly do not exhaust scrutinee type {}"
                % [scrutinee.type_].stringify;
            [state].error_at_previous msg: [msg];
        };
    };

    return GivenExpression [
        start, [state].last_end, [maybe_result_type_] || [NullType_ []],
        scrutinee, arms, maybe_else_block, else_never
    ];
}

ForExpression?#parse for_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    ExprContext:block_ctx = [ctx].new_scope;
    LoopCtx:loop_ctx = LoopCtx [
        [BreakExpression] [], [ContinueExpression] []
    ];
    block_ctx.loop_ctx = loop_ctx;

    SubVarDeclNode?:maybe_var_decl = parse explicit var decl [state] ctx: [block_ctx];
    if !maybe_var_decl {
        return null;
    };
    SubVarDeclNode:var_decl = [maybe_var_decl].unwrap;

    ToForClause?:maybe_to = null;
    FromForClause?:maybe_from = null;
    StepForClause?:maybe_step = null;
    InForClause?:maybe_in = null;
    EnumeratingForClause?:maybe_enumerating = null;
    WhereForClause?:maybe_where = null;
    MapForClause?:maybe_map = null;

    while ![state].is_at_end && [state].cur_id != T_CURLY_GROUP {
        if ![state].consume[T_IDENT] name: ["for clause name"] {
            return null;
        };

        W:clause_start = [state].last_start;

        Str:clause_name = [[state].last_data].read_identifier;
        switch clause_name
        ("to") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_to = ToForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("from") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_from = FromForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("step") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_step = StepForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("in") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_in = InForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("enumerating") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_enumerating = EnumeratingForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("where") {
            given parse expr [state] ctx: [block_ctx] as $Expression:val {
                maybe_where = WhereForClause [
                    clause_start, [state].last_end, val, block_ctx.scope
                ];
            } else {return null;};
        }
        ("map") {
            maybe_map = MapForClause [clause_start, [state].last_end];
        }
        {
            [state].error_at_previous
                msg: ["Invalid for loop clause name '{}'" % clause_name];
            return null;
        };
    };

    Block?:maybe_block = parse block [state] ctx: [block_ctx];
    if !maybe_block {
        return null;
    };
    Block:block = [maybe_block].unwrap;

    Block?:maybe_else_block = null;
    if [[state].try_read_ident] equals ["else"#Str?] {
        [state].consume;
        ExprContext:else_ctx = [ctx].new_scope;
        maybe_else_block = parse block [state] ctx: [else_ctx];
        if !maybe_else_block {
            return null;
        };
    };

    $Type_:idx_type_ = var_decl.var.type_;
    given maybe_in as InForClause:in_clause {
        idx_type_ = WType_ [64];
    };

    given maybe_in as InForClause:in_clause {
        given maybe_enumerating as EnumeratingForClause:enumerating_clause {
            Str:msg = "For loops cannot have both an 'in' and an 'enumerating' clause";
            [state].error_at[in_clause] msg: [msg];
        };
    } else {
        if ![var_decl.var.type_].is_int {
            [state].error_at[var_decl]
                msg: ["Loop variable type must be an integer"];
        };
    };

    given maybe_enumerating as EnumeratingForClause:enumerating_clause {
        given maybe_to as ToForClause:to_clause {
            Str:msg = "For loops cannot have both a 'to' and an 'enumerating' clause";
            [state].error_at[to_clause] msg: [msg];
        };
    };

    given maybe_where as WhereForClause:where_clause {
        given where_clause.val.type_ as NullType_:null_type_ {
            [state].error_at[where_clause]
                msg: ["The 'where' clause must hold a condition, this expression has type Null"];
        };
    };

    if !maybe_to && !maybe_in && !maybe_enumerating {
        [state].error_between [start] and [[state].last_end]
            msg: ["For loops must have a 'to', 'in', or 'enumerating' clause"];
    };

    given maybe_to as ToForClause:to_clause {
        if ![to_clause.val.type_] is convertible to [idx_type_] {
            Str:msg = "'to' clause value type must be convertible to {}, found type {}"
                % [idx_type_].stringify % [to_clause.val.type_].stringify;
            [state].error_at[to_clause] msg: [msg];
        };
    };
    given maybe_from as FromForClause:from_clause {
        if ![from_clause.val.type_] is convertible to [idx_type_] {
            Str:msg = "'from' clause value type must be convertible to {}, found type {}"
                % [idx_type_].stringify % [from_clause.val.type_].stringify;
            [state].error_at[from_clause] msg: [msg];
        };
    };
    given maybe_step as StepForClause:step_clause {
        if ![step_clause.val.type_].is_int {
            Str:msg = "'step' clause value must be an integer, found value of type {}"
                % [step_clause.val.type_].stringify;
            [state].error_at[step_clause] msg: [msg];
        };
    };
    given maybe_in as InForClause:in_clause {
        $Type_:target_type_ = Array_ of [var_decl.var.type_];
        if ![in_clause.val.type_] is convertible to [target_type_] {
            Str:msg = "'in' clause value type must be convertible to {}, found {}"
                % [target_type_].stringify % [in_clause.val.type_].stringify;
            [state].error_at[in_clause] msg: [msg];
        };
    };
    given maybe_enumerating as EnumeratingForClause:enumerating_clause {
        GenericType_Criteria:criteria = GenericType_Criteria [
            "Array", [$Type_Criteria] [AnyType_Criteria []]
        ];
        if ![enumerating_clause.val.type_].satisfies[criteria] {
            Str:msg = "'enumerating' clause value must be an Array, found type {}"
                % [enumerating_clause.val.type_].stringify;
            [state].error_at[enumerating_clause] msg: [msg];
        };
    };

    $Type_:result_type_ = NullType_ [];

    given maybe_map as MapForClause:map_clause {
        result_type_ = Array_ of [block.type_];

        for BreakExpression:break_expr in loop_ctx.breaks {
            if !(break_expr.result.type_#NullType_?) {
                Str:msg = "Breaks in for loops with map clauses must produce Null, got type {}"
                    % [break_expr.result.type_].stringify;
                [state].error_at[break_expr] msg: [msg];
            };
        };

        given maybe_else_block as Block:else_block {
            if !(else_block.type_#NullType_?) {
                Str:msg = "Else blocks on for loops with map clauses must produce Null, got type {}"
                    % [else_block.type_].stringify;
                [state].error_at[[else_block.lines].at[-1]] msg: [msg];
            };
        };
    } else {
        given maybe_else_block as Block:else_block {
            result_type_ = else_block.type_;
            for BreakExpression:break_ in loop_ctx.breaks {
                given common type_ between [result_type_] and [break_.result.type_]
                as $Type_:common_type_ {
                    result_type_ = common_type_;
                } else {
                    result_type_ = NullType_ [];
                    break;
                };
            };
        };
    };

    return ForExpression [
        start, [state].last_end, result_type_, var_decl.var,
        maybe_to, maybe_from, maybe_step, maybe_in, maybe_enumerating,
        maybe_where, maybe_map,
        block, maybe_else_block
    ];
}

$Expression?#parse ident [Str:ident] expr [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;
    switch ident
    ("null") {
        return NullExpression [
            start, [state].last_end, NullType_ []
        ];
    }
    ("return") {
        W:pos = [state].last_end + 1;
        $Expression:returnee = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_returnee {
                returnee = explicit_returnee;
            } else {
                return null;
            };
        };
        if ![returnee.type_] is convertible to [ctx.func_decl.ret_type_] {
            Str:msg = "Value of type {} not convertible to the return type, {}"
                % [returnee.type_].stringify % [ctx.func_decl.ret_type_].stringify;
            [state].error_at[returnee] msg: [msg];
        };
        return ReturnExpression [
            start, [state].last_end, NeverType_ [], returnee
        ];
    }
    ("break") {
        W:pos = [state].last_end + 1;
        $Expression:result = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_result {
                result = explicit_result;
            } else {
                return null;
            };
        };
        BreakExpression:break_ = BreakExpression [
            start, [state].last_end, NeverType_ [], result
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            [loop_ctx.breaks].append[break_];
        } else {
            [state].error_at[break_]
                msg: ["break keyword invalid when not inside loop"];
        };
        return break_;
    }
    ("continue") {
        ContinueExpression:continue_ = ContinueExpression [
            start, [state].last_end, NeverType_ []
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            [loop_ctx.continues].append[continue_];
        } else {
            [state].error_at[continue_]
                msg: ["continue keyword invalid when not inside loop"];
        };
        return continue_;
    }
    ("true") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], true
        ];
    }
    ("false") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], false
        ];
    }
    ("while") {
        return parse while_ [state] ctx: [ctx];
    }
    ("if") {
        return parse if_ [state] ctx: [ctx];
    }
    ("given") {
        return parse given_ [state] ctx: [ctx];
    }
    ("for") {
        return parse for_ [state] ctx: [ctx];
    }
    { // it's a variable
        if ![state].is_at_end && [state].cur_id == ':' {
            return parse var decl ident: [ident] state: [state] ctx: [ctx];
        };
        given lookup variable [ident] in [ctx.scope.chain] as ScopeVar:var {
            return VariableExpression [
                start, [state].last_end, var.type_, var
            ];
        } else {
            [state].error_at_previous
                msg: ["The name '{}' cannot be found here" % ident];
            return null;
        };
    };
}

$Expression?#assign [$Expression:value] to [$Expression:recipient] state: [ParseState: state] {
    if ![value.type_] is convertible to [recipient.type_] {
        Str:msg = "Cannot assign value of type {} to recipient expecting a type convertible to {}"
            % [value.type_].stringify % [recipient.type_].stringify;
        [state].error_at[value] msg: [msg];
    };
    given recipient as VariableExpression:var_expr {
        return VariableAssignmentExpression [
            recipient.start_index, value.end_index, NullType_ [],
            var_expr.var, value
        ];
    } else {
        [state].error_at[recipient] msg: ["Cannot assign to this expression"];
        return null;
    };
}

$Expression?#parse expr postfix [ParseState:state] on: [$Expression:base] ctx: [ExprContext:ctx] {
    if [state].is_at_end {
        return base;
    };

    if [state].cur_id == '.' {
        [state].consume;

        if ![state].consume[T_IDENT] name: ["member name"] {
            [state].unconsume;
            return null;
        };

        Str:member_name = [[state].last_data].read_identifier;

        abort ["member access not yet implemented"];

    } elif [state].cur_id == '#' {
        [state].consume;

        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:to_type_ {
            if ![base.type_] is castable to [to_type_] {
                Str:msg = "Cannot cast value of type {} to type {}"
                    % [base.type_].stringify % [to_type_].stringify;
                [state].error_at[base] msg: [msg];
            };
            return CastExpression [
                base.start_index, [state].last_end, to_type_, base
            ];
        } else {
            return null;
        };
    };

    return base;
}

$Expression?#parse expr term [ParseState:state] ctx: [ExprContext:ctx] {
    given parse expr term inner [state] ctx: [ctx] as $Expression:expr {
        while true {
            given parse expr postfix [state] on: [expr] ctx: [ctx]
            as $Expression:postfix_expr {
                if expr == postfix_expr {
                    return expr;
                };
                expr = postfix_expr;
            } else {
                return null;
            };
        };
    } else {
        return null;
    };
}

BiOperator?#match [BiOperatorLevel:level] against [ParseState:state] {
    if [state].is_at_end {
        return null;
    };
    L:index = state.index;
    for BiOperator:operator in level.operators {
        Bool:failed = false;
        for Byte:byte in operator.spelling {
            if [state].cur_id != byte {
                failed = true;
                break;
            };
            [state].consume;
        };
        if !failed && [state].cur_id != '=' {
            return operator;
        };
        state.index = index;
    };
    return null;
}

Bool#expect [$Expression:expr] satisfies [$Type_Criteria:criteria] state: [ParseState:state] template: [Str:template] {
    if [expr.type_].satisfies[criteria] {
        return true;
    };
    [state].error_at[expr] msg: [template % [expr.type_].stringify];
    return false;
}

Bool#expect numeric [$Expression:a] and [$Expression:b] op: [BiOperator:operator] state: [ParseState:state] {
    Str:template = "'{}' expects a number, found {}" % operator.spelling % "{}";
    $Type_Criteria:criteria = NumericType_Criteria [];
    return
        expect [a] satisfies [criteria] state: [state] template: [template]
        && expect [b] satisfies [criteria] state: [state] template: [template];
}

Bool#expect comparable [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    if !types_ [a.type_] and [b.type_] are compatible {
        Str:msg = "Cannot compare types {} and {}"
            % [a.type_].stringify % [b.type_].stringify;
        [state].error_at [[$Node] [a, b]] msg: [msg];
        return false;
    };
    return true;
}

$Type_?#type_ for_ [BiOperator:operator] on [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_:at = a.type_;
    $Type_:bt = b.type_;

    Str:spelling = operator.spelling;
    if ([spelling] equals ["&&"]) || ([spelling] equals ["||"]) {
        return BoolType_ [1];
    } elif ([spelling] equals [">"]) || ([spelling] equals ["<"])
        || ([spelling] equals [">="]) || ([spelling] equals ["<="]) {
        expect numeric [a] and [b] op: [operator] state: [state];
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["=="]) || ([spelling] equals ["!="]) {
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["+"]) || ([spelling] equals ["-"])
        || ([spelling] equals ["*"]) || ([spelling] equals ["%"]) {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["/"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        W:bits = 64;
        given at as RType_:at_R {
            bits = at_R.bits;
        };
        return RType_ [bits];
    } elif [spelling] equals ["~/"] {
        Str:template = "'~/' expects an integer, found {}";
        $Type_Criteria:criteria = IntType_Criteria [];
        if !expect [a] satisfies [criteria] state: [state] template: [template]
            && expect [b] satisfies [criteria] state: [state] template: [template] {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["**"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        $Type_:t = RType_ [[at#$NumericType_?].unwrap.bits];
        given bt as UnsignedIntegerType_:uint_type_ {
            t = at;
        };
        return t;
    } elif ([spelling] equals ["="]) || ([spelling] equals ["+="])
        || ([spelling] equals ["-="]) || ([spelling] equals ["*="])
        || ([spelling] equals ["/="]) || ([spelling] equals ["%="]) {
        return NullType_ [];
    } else {
        abort ["Operator {} not implemented" % operator.spelling];
    };
}

$Expression?#[BiOperator:op] on [$Expression:a] and [$Expression:b] state: [ParseState:state] b_scope: [ExprScope:b_scope] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_?:maybe_t = type_ for_ [op] on [a] and [b] state: [state];
    if !maybe_t {
        return null;
    };
    $Type_:t = [maybe_t].unwrap;
    Str:spelling = op.spelling;
    switch spelling
    ("&&") {return AndExpression [s, e, t, a, b, b_scope];}
    ("||") {return OrExpression [s, e, t, a, b, b_scope];}
    (">") {return GreaterExpression [s, e, t, a, b];}
    ("<") {return LessExpression [s, e, t, a, b];}
    (">=") {return GreaterEqualExpression [s, e, t, a, b];}
    ("<=") {return LessEqualExpression [s, e, t, a, b];}
    ("==") {return EqualExpression [s, e, t, a, b];}
    ("!=") {return NotEqualExpression [s, e, t, a, b];}
    ("+") {return PlusExpression [s, e, t, a, b];}
    ("-") {return MinusExpression [s, e, t, a, b];}
    ("*") {return MultiplyExpression [s, e, t, a, b];}
    ("/") {return DivideExpression [s, e, t, a, b];}
    ("~/") {return IntDivideExpression [s, e, t, a, b];}
    ("%") {return ModuloExpression [s, e, t, a, b];}
    ("**") {return ExponentiationExpression [s, e, t, a, b];}
    ("=") {return assign [b] to [a] state: [state];};
    if ([spelling] equals ["+="]) || ([spelling] equals ["-="])
        || ([spelling] equals ["*="]) || ([spelling] equals ["/="])
        || ([spelling] equals ["%="]) {
        return inplace op [op] on [a] and [b] state: [state] b_scope: [b_scope];
    };
    abort ["Operator {} not implemented" % op.spelling];
}

$Expression?#inplace op [BiOperator:op] on [$Expression:a] and [$Expression:b] state: [ParseState:state] b_scope: [ExprScope:b_scope] {
    // cut off the last char of the op ("+=" -> "+")
    Str:sub_op_name = [op.spelling].slice[0][[op.spelling].len - 1];
    BiOperator:sub_op = BiOperator [sub_op_name, op.cond_eval];
    given [sub_op] on [a] and [b] state: [state] b_scope: [b_scope]
    as $Expression:op_result {
        return assign [op_result] to [a] state: [state];
    } else {
        return null;
    };
}

$Expression?#parse expr [ParseState:state] ctx: [ExprContext:ctx] {
    $Expression?:maybe_first_term = parse expr term [state] ctx: [ctx];
    if !maybe_first_term {
        return null;
    };
    $Expression:first_term = [maybe_first_term].unwrap;
    if [state].is_at_end || [state].cur_id == ';' || [state].cur_id == ',' {
        return first_term;
    };

    L:level_count = [get bioperator levels].len;
    [$Expression?]:stack = [$Expression?]*level_count;
    [BiOperator?]:operator_stack = [BiOperator?]*level_count;
    [ExprContext?]:ctx_stack = [ExprContext?]*level_count;

    stack[level_count - 1] = first_term;
    ctx_stack[level_count - 1] = ctx;
    L:stack_i = level_count - 1;

    while true {
        BiOperatorLevel:level = get bioperator levels[stack_i];

        ExprContext:op_ctx = [ctx_stack[stack_i]].unwrap;

        BiOperator?:maybe_matching_operator = match [level] against [state];

        $Expression?:maybe_b = null;
        given maybe_matching_operator as BiOperator:operator {
            if operator.cond_eval {
                // the operator may sometimes not evaluate the second operand
                // (what we are parsing right now), so we need to parse it
                // in its own ExprContext so variables defined here aren't
                // avaliable externally
                op_ctx = [op_ctx].new_scope;
            };
            given parse expr term [state] ctx: [op_ctx] as $Expression:b {
                operator_stack[stack_i] = operator;
                maybe_b = b;
                stack_i = level_count - 1;
            } else {
                return null;
            };
        } else {
            $Expression:b = [stack[stack_i]].unwrap;
            if stack_i == 0 {
                return b;
            };
            maybe_b = b;
            stack[stack_i] = null;
            stack_i -= 1;
        };

        $Expression:b = [maybe_b].unwrap;
        given stack[stack_i] as $Expression:a {
            BiOperator:operator = [operator_stack[stack_i]].unwrap;
            given [operator] on [a] and [b] state: [state] b_scope: [op_ctx.scope]
            as $Expression:expr {
                stack[stack_i] = expr;
            } else {
                return null;
            };
        } else {
            stack[stack_i] = b;
        };
        ctx_stack[stack_i] = op_ctx;
    };
}

Block?#parse block inside [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].cur_start;
    ExprContext:block_ctx = [ctx].new_scope;
    [$Expression]:lines = [$Expression] [];
    $Type_?:maybe_type_ = null;
    while ![state].is_at_end {
        given parse expr [state] ctx: [block_ctx] as $Expression:expr {
            [lines].append[expr];
            maybe_type_ = expr.type_;
        } else {
            // error recovery
            while ![state].is_at_end && [state].cur_id != ';' {
                [state].consume;
            };
        };
        if [state].is_at_end {
            break;
        } elif [state].cur_id == ';' {
            [state].consume;
        } else {
            [state].error_at_current msg: ["Expected ';' to terminate statement"];
            while ![state].is_at_end && [state].last_id != ';' {
                [state].consume;
            };
        };
        maybe_type_ = null;
    };
    if !maybe_type_ {
        NullType_:type_ = NullType_ [];
        W:pos = [state].last_end + 1;
        [lines].append[NullExpression [pos, pos, type_]];
        maybe_type_ = type_;
    };
    return Block [start, [state].last_end, [maybe_type_].unwrap, lines, ctx.scope];
}

Block?#parse block [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].consume[T_CURLY_GROUP] {
        return null;
    };
    ParseState:inner_state = [state].last_substate;
    return parse block inside [inner_state] ctx: [ctx];
}
