%import epslfiles;
%import tokenizer;
%import epslctx;
%import parsing;
%import types_;
%import exprs;

BiOperator {
    [Byte]:spelling,
    Bool:cond_eval
}

BiOperatorLevel {
    [BiOperator]:operators,
}

%global [BiOperatorLevel]?:bioperator_levels_cache;

[BiOperatorLevel]#get bioperator levels {
    given bioperator_levels_cache as [BiOperatorLevel]:bioperator_levels {
        return bioperator_levels;
    };
    [BiOperatorLevel]:bioperator_levels = [BiOperatorLevel] [
        BiOperatorLevel [[BiOperator] [
            BiOperator ["&&", true], BiOperator ["||", true]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator [">", false], BiOperator ["<", false],
            BiOperator [">=", false], BiOperator ["<=", false],
            BiOperator ["==", false], BiOperator ["!=", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["+", false], BiOperator ["-", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["*", false], BiOperator ["/", false],
            BiOperator ["~/", false], BiOperator ["%", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["**", false]
        ]],
    ];
    bioperator_levels_cache = bioperator_levels;
    return bioperator_levels;
}

$Expression?#parse expr term inner [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].require_more why: ["Expected expression"] {
        return null;
    };

    W:start = [state].cur_start;
    [state].consume;

    // STEP: check for function calls

    // STEP: check for constants
    if [state].last_id == T_INT {
        Z64:val = [(IntTokenData?)[state].last_data].unwrap.val;
        $NumericType_:type_ = ZType_ [64];
        if val > 0 {
            if val > (Z64)~[(W32)0] {
                type_ = WType_ [64];
            } else {
                type_ = WType_ [32];
            };
        } else {
            if val > -[(Z64)1] << [31] {
                type_ = ZType_ [32];
            };
        };
        return IntConstantExpression [
            start, [state].last_end, type_, val
        ];
    } elif [state].last_id == T_FLOAT {
        R:val = [(FloatTokenData?)[state].last_data].unwrap.val;
        return FloatConstantExpression [
            start, [state].last_end, RType_ [64], val
        ];
    } elif [state].last_id == T_BYTE {
        Byte:val = [(ByteTokenData?)[state].last_data].unwrap.val;
        return ByteConstantExpression [
            start, [state].last_end, ByteType_ [8], val
        ];
    } elif [state].last_id == T_STR {
        Str:val = [(StrTokenData?)[state].last_data].unwrap.val;
        return StrConstantExpression [
            start, [state].last_end, Str_, val
        ];

    // STEP: check for prefix operators
    } elif [state].last_id == '-' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            Str:template = "'-' expects a number, found {}";
            if !expect [operand] satisfies [NumericType_Criteria []] state: [state] template: [template] {
                return null;
            };
            $Type_:type_ = operand.type_;
            given type_ as $UnsignedIntegerType_:uint_type_ {
                type_ = ZType_ [uint_type_.bits];
            };
            given operand as IntConstantExpression:int_const {
                int_const.type_ = type_;
                int_const.val *= -1;
                int_const.start_index = start;
                return int_const;
            } given operand as FloatConstantExpression:float_const {
                float_const.val *= -1;
                float_const.start_index = start;
                return float_const;
            };
            return NegateExpression [
                start, [state].last_end, type_, operand
            ];
        } else {
            return null;
        };
    } elif [state].last_id == '!' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            return NotExpression [
                start, [state].last_end, BoolType_ [1], operand
            ];
        } else {
            return null;
        };

    // STEP: check for parenthesis groups
    } elif [state].last_id == T_PAREN_GROUP {
        given parse expr [[state].last_substate] ctx: [ctx] as $Expression:inner {
            return ParenExpression [start, [state].last_end, inner.type_, inner];
        } else {
            return null;
        };

    // STEP: check for exprs starting with an identifier
    } elif [state].last_id == T_IDENT {
        Str:ident = [[state].last_data].read_identifier;
        return parse ident [ident] expr [state] ctx: [ctx];
    };

    [state].unconsume;
    [state].error_about_current msg: ["Expected expression"];
    return null;
}

$Expression?#parse var decl ident: [Str:ident] state: [ParseState:state] ctx: [ExprContext:ctx] {
    // this function is to be called when a var decl has been detected,
    // but the ':' has not been consumed

    W:start = [state].last_start;
    [state].consume; // eat the ':'

    $Type_?:maybe_type_ = null;
    if [state].cur_id != '=' {
        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:type_ {
            maybe_type_ = type_;
        } else {
            return null;
        };
    };
    if ![state].consume['='] {
        return null;
    };

    $Expression?:maybe_initializer = null;

    given parse expr [state] ctx: [ctx] as $Expression:initializer {
        maybe_initializer = initializer;
        given maybe_type_ as $Type_:var_type_ {
            if ![initializer.type_] is convertible to [var_type_] {
                Str:msg = "Cannot assign value of type {} to variable wit type {}"
                    % [initializer.type_].stringify % [var_type_].stringify;
                [state].error_at[initializer] msg: [msg];
            };
        } else {
            given initializer.type_ as NullType_:null_type_ {
                [state].error_at[initializer]
                    msg: ["Variable type cannot be inferred to initializer type Null"];
            };
            maybe_type_ = initializer.type_;
        };
    };

    given maybe_type_ as $Type_:var_type_ {
        ScopeVar:var = add var [ident] type_: [[maybe_type_].unwrap] to: [ctx];
        given maybe_initializer as $Expression:initializer {
            return VariableDeclarationExpression [
                start, [state].last_end, NullType_ [], var, initializer
            ];
        };
    };

    return null;
}

WhileExpression?#parse while_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    ExprContext:cond_ctx = [ctx].branch;
    $Expression?:maybe_cond = parse expr [state] ctx: [cond_ctx];
    if !maybe_cond {
        return null;
    };
    $Expression:cond = [maybe_cond].unwrap;

    ExprContext:block_ctx = [ctx].branch;
    LoopCtx:loop_ctx = LoopCtx [
        [BreakExpression] [], [ContinueExpression] []
    ];
    block_ctx.loop_ctx = loop_ctx;
    Block?:maybe_block = parse block [state] ctx: [block_ctx];
    if !maybe_block {
        return null;
    };
    Block:block = [maybe_block].unwrap;

    $Type_?:maybe_base_type_ = null;

    Block?:maybe_else_block = null;
    if [[state].try_read_ident] equals [(Str?)"else"] {
        [state].consume;
        given parse block [state] ctx: [ctx] as Block:else_block {
            maybe_else_block = else_block;
            maybe_base_type_ = else_block.type_;
        } else {
            return null;
        };
    };

    given cond as $ConstantExpression:const_expr {
        if [const_expr].is_truthy {
            maybe_base_type_ = NeverType_ [];
        };
    };

    $Type_:type_ = NullType_ [];
    given maybe_base_type_ as $Type_:base_type_ {
        type_ = base_type_;
        for BreakExpression:break_ in loop_ctx.breaks {
            given common type_ between [type_] and [break_.result.type_]
            as $Type_:common_type_ {
                type_ = common_type_;
            } else {
                type_ = NullType_ [];
                break;
            };
        };
    };

    return WhileExpression [
        start, [state].last_end, type_, cond, block, maybe_else_block
    ];
}

IfExpression?#parse if_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    [IfBranch]:branches = [IfBranch] [];

    $Type_?:maybe_type_ = NeverType_ [];

    Bool:has_else = false;
    while true {
        ctx = [ctx].branch;
        $Expression?:maybe_cond = parse expr [state] ctx: [ctx];
        if !maybe_cond {
            return null;
        };
        $Expression:cond = [maybe_cond].unwrap;

        ctx = [ctx].branch;
        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [block.type_];
        };

        [branches].append[IfBranch [cond, block]];

        Str?:next_ident = [state].try_read_ident;

        if [next_ident] equals [(Str?)"elif"] {
            [state].consume;
            continue;
        } elif [next_ident] equals [(Str?)"else"] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Block?:maybe_else_block = null;
    if has_else {
        ctx = [ctx].branch;
        maybe_else_block = parse block [state] ctx: [ctx];
        if !maybe_else_block {
            return null;
        };
        Block:else_block = [maybe_else_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [else_block.type_];
        };
    } else {
        maybe_type_ = null;
    };

    $Type_:type_ = [maybe_type_] || [NullType_ []];

    return IfExpression [
        start, [state].last_end, type_, branches, maybe_else_block
    ];
}

$Expression?#parse ident [Str:ident] expr [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;
    switch ident
    ("null") {
        return NullExpression [
            start, [state].last_end, NullType_ []
        ];
    }
    ("return") {
        W:pos = [state].last_end + 1;
        $Expression:returnee = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_returnee {
                returnee = explicit_returnee;
            } else {
                return null;
            };
        };
        if ![returnee.type_] is convertible to [ctx.func_decl.ret_type_] {
            Str:msg = "Value of type {} not convertible to the return type, {}"
                % [returnee.type_].stringify % [ctx.func_decl.ret_type_].stringify;
            [state].error_at[returnee] msg: [msg];
        };
        return ReturnExpression [
            start, [state].last_end, NeverType_ [], returnee
        ];
    }
    ("break") {
        W:pos = [state].last_end + 1;
        $Expression:result = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_result {
                result = explicit_result;
            } else {
                return null;
            };
        };
        BreakExpression:break_ = BreakExpression [
            start, [state].last_end, NeverType_ [], result
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            [loop_ctx.breaks].append[break_];
        } else {
            [state].error_at[break_]
                msg: ["break keyword invalid when not inside loop"];
        };
        return break_;
    }
    ("continue") {
        ContinueExpression:continue_ = ContinueExpression [
            start, [state].last_end, NeverType_ []
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            [loop_ctx.continues].append[continue_];
        } else {
            [state].error_at[continue_]
                msg: ["continue keyword invalid when not inside loop"];
        };
        return continue_;
    }
    ("true") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], true
        ];
    }
    ("false") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], false
        ];
    }
    ("while") {
        return parse while_ [state] ctx: [ctx];
    }
    ("if") {
        return parse if_ [state] ctx: [ctx];
    }
    // TODO: add other keywords here
    { // it's a variable
        if ![state].is_at_end && [state].cur_id == ':' {
            return parse var decl ident: [ident] state: [state] ctx: [ctx];
        };
        given lookup variable [ident] in [ctx.scope_chain] as ScopeVar:var {
            return VariableExpression [
                start, [state].last_end, var.type_, var
            ];
        } else {
            [state].error_at_previous
                msg: ["The name '{}' cannot be found here" % ident];
            return null;
        };
    };
}

$Expression?#parse expr postfix [ParseState:state] on: [$Expression:base] ctx: [ExprContext:ctx] {
    if [state].is_at_end {
        return base;
    };

    if [state].cur_id == '.' {
        [state].consume;

        if ![state].consume[T_IDENT] name: ["member name"] {
            [state].unconsume;
            return null;
        };

        Str:member_name = [[state].last_data].read_identifier;

        abort ["member access not yet implemented"];

    } elif [[state].try_read_ident] equals [(Str?)"as"] {
        [state].consume;

        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:to_type_ {
            if ![base.type_] is castable to [to_type_] {
                Str:msg = "Cannot cast value of type {} to type {}"
                    % [base.type_].stringify % [to_type_].stringify;
                [state].error_at[base] msg: [msg];
            };
            return CastExpression [
                base.start_index, [state].last_end, to_type_, base
            ];
        } else {
            return null;
        };
    };

    return base;
}

$Expression?#parse expr term [ParseState:state] ctx: [ExprContext:ctx] {
    given parse expr term inner [state] ctx: [ctx] as $Expression:expr {
        while true {
            given parse expr postfix [state] on: [expr] ctx: [ctx]
            as $Expression:postfix_expr {
                if expr == postfix_expr {
                    return expr;
                };
                expr = postfix_expr;
            } else {
                return null;
            };
        };
    } else {
        return null;
    };
}

BiOperator?#match [BiOperatorLevel:level] against [ParseState:state] {
    if [state].is_at_end {
        return null;
    };
    L:index = state.index;
    for BiOperator:operator in level.operators {
        Bool:failed = false;
        for Byte:byte in operator.spelling {
            if [state].cur_id != byte {
                failed = true;
                break;
            };
            [state].consume;
        };
        if !failed {
            return operator;
        };
        state.index = index;
    };
    return null;
}

Bool#expect [$Expression:expr] satisfies [$Type_Criteria:criteria] state: [ParseState:state] template: [Str:template] {
    if [expr.type_].satisfies[criteria] {
        return true;
    };
    [state].error_at[expr] msg: [template % [expr.type_].stringify];
    return false;
}

Bool#expect numeric [$Expression:a] and [$Expression:b] op: [BiOperator:operator] state: [ParseState:state] {
    Str:template = "'{}' expects a number, found {}" % operator.spelling % "{}";
    $Type_Criteria:criteria = NumericType_Criteria [];
    return
        expect [a] satisfies [criteria] state: [state] template: [template]
        && expect [b] satisfies [criteria] state: [state] template: [template];
}

Bool#expect comparable [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    if !types_ [a.type_] and [b.type_] are compatible {
        Str:msg = "Cannot compare types {} and {}"
            % [a.type_].stringify % [b.type_].stringify;
        [state].error_at [[$Node] [a, b]] msg: [msg];
        return false;
    };
    return true;
}

$Type_?#type_ for_ [BiOperator:operator] on [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_:at = a.type_;
    $Type_:bt = b.type_;

    Str:spelling = operator.spelling;
    if ([spelling] equals ["&&"]) || ([spelling] equals ["||"]) {
        return BoolType_ [1];
    } elif ([spelling] equals [">"]) || ([spelling] equals ["<"])
        || ([spelling] equals [">="]) || ([spelling] equals ["<="]) {
        expect numeric [a] and [b] op: [operator] state: [state];
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["=="]) || ([spelling] equals ["!="]) {
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["+"]) || ([spelling] equals ["-"])
        || ([spelling] equals ["*"]) || ([spelling] equals ["%"]) {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["/"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        W:bits = 64;
        given at as RType_:at_R {
            bits = at_R.bits;
        };
        return RType_ [bits];
    } elif [spelling] equals ["~/"] {
        Str:template = "'~/' expects an integer, found {}";
        $Type_Criteria:criteria = IntType_Criteria [];
        if !expect [a] satisfies [criteria] state: [state] template: [template]
            && expect [b] satisfies [criteria] state: [state] template: [template] {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["**"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        $Type_:t = RType_ [[($NumericType_?)at].unwrap.bits];
        given bt as UnsignedIntegerType_:uint_type_ {
            t = at;
        };
        return t;
    } else {
        abort ["Operator {} not implemented" % operator.spelling];
    };
}

$BiOperationExpression?#[BiOperator:operator] on [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_?:maybe_t = type_ for_ [operator] on [a] and [b] state: [state];
    if !maybe_t {
        return null;
    };
    $Type_:t = [maybe_t].unwrap;
    switch operator.spelling
    ("&&") {return AndExpression [s, e, t, a, b];}
    ("||") {return OrExpression [s, e, t, a, b];}
    (">") {return GreaterExpression [s, e, t, a, b];}
    ("<") {return LessExpression [s, e, t, a, b];}
    (">=") {return GreaterEqualExpression [s, e, t, a, b];}
    ("<=") {return LessEqualExpression [s, e, t, a, b];}
    ("==") {return EqualExpression [s, e, t, a, b];}
    ("!=") {return NotEqualExpression [s, e, t, a, b];}
    ("+") {return PlusExpression [s, e, t, a, b];}
    ("-") {return MinusExpression [s, e, t, a, b];}
    ("*") {return MultiplyExpression [s, e, t, a, b];}
    ("/") {return DivideExpression [s, e, t, a, b];}
    ("~/") {return IntDivideExpression [s, e, t, a, b];}
    ("%") {return ModuloExpression [s, e, t, a, b];}
    ("**") {return ExponentiationExpression [s, e, t, a, b];}
    {
        abort ["Operator {} not implemented" % operator.spelling];
    };
}

$Expression?#parse expr [ParseState:state] ctx: [ExprContext:ctx] {
    $Expression?:maybe_first_term = parse expr term [state] ctx: [ctx];
    if !maybe_first_term {
        return null;
    };
    $Expression:first_term = [maybe_first_term].unwrap;
    if [state].is_at_end {
        return first_term;
    };

    L:level_count = [get bioperator levels].len;
    [$Expression?]:stack = [$Expression?]*level_count;
    [BiOperator?]:operator_stack = [BiOperator?]*level_count;
    [ExprContext?]:ctx_stack = [ExprContext?]*level_count;

    stack[level_count - 1] = first_term;
    ctx_stack[level_count - 1] = ctx;
    L:stack_i = level_count - 1;

    while true {
        BiOperatorLevel:level = get bioperator levels[stack_i];

        ExprContext:op_ctx = [ctx_stack[stack_i]].unwrap;

        BiOperator?:maybe_matching_operator = match [level] against [state];

        $Expression?:maybe_b = null;
        given maybe_matching_operator as BiOperator:operator {
            if operator.cond_eval {
                // the operator may sometimes not evaluate the second operand,
                // (what we are parsing right now), so we need to parse it
                // in its own ExprContext so variables defined here aren't
                // avaliable externally
                op_ctx = [op_ctx].branch;
            };
            given parse expr term [state] ctx: [op_ctx] as $Expression:b {
                operator_stack[stack_i] = operator;
                maybe_b = b;
                stack_i = level_count - 1;
            } else {
                return null;
            };
        } else {
            $Expression:b = [stack[stack_i]].unwrap;
            if stack_i == 0 {
                return b;
            };
            maybe_b = b;
            stack[stack_i] = null;
            stack_i -= 1;
        };

        $Expression:b = [maybe_b].unwrap;
        given stack[stack_i] as $Expression:a {
            BiOperator:operator = [operator_stack[stack_i]].unwrap;
            given [operator] on [a] and [b] state: [state] as $Expression:expr {
                stack[stack_i] = expr;
            } else {
                return null;
            };
        } else {
            stack[stack_i] = b;
        };
        ctx_stack[stack_i] = op_ctx;
    };

    return stack[stack_i];
}

Block?#parse block inside [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].cur_start;
    ExprContext:block_ctx = [ctx].branch;
    [$Expression]:lines = [$Expression] [];
    $Type_?:maybe_type_ = null;
    while ![state].is_at_end {
        given parse expr [state] ctx: [block_ctx] as $Expression:expr {
            [lines].append[expr];
            maybe_type_ = expr.type_;
        } else {
            // error recovery
            while ![state].is_at_end && [state].cur_id != ';' {
                [state].consume;
            };
        };
        if [state].is_at_end {
            break;
        } elif [state].cur_id == ';' {
            [state].consume;
        } else {
            [state].error_at_current msg: ["Expected ';' to terminate statement"];
            while ![state].is_at_end && [state].last_id != ';' {
                [state].consume;
            };
        };
        maybe_type_ = null;
    };
    if !maybe_type_ {
        NullType_:type_ = NullType_ [];
        W:pos = [state].last_end + 1;
        [lines].append[NullExpression [pos, pos, type_]];
        maybe_type_ = type_;
    };
    return Block [start, [state].last_end, [maybe_type_].unwrap, lines];
}

Block?#parse block [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].consume[T_CURLY_GROUP] {
        return null;
    };
    ParseState:inner_state = [state].last_substate;
    return parse block inside [inner_state] ctx: [ctx];
}
