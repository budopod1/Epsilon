%import epslfiles;
%import tokenizer;
%import functions;
%import epslctx;
%import parsing;
%import structs;
%import types_;
%import exprs;

BiOperator {
    [Byte]:spelling,
    Bool:cond_eval
}

BiOperatorLevel {
    [BiOperator]:operators,
}

%global [BiOperatorLevel]?:bioperator_levels_cache;

[BiOperatorLevel]#get bioperator levels {
    given bioperator_levels_cache as [BiOperatorLevel]:bioperator_levels {
        return bioperator_levels;
    };
    [BiOperatorLevel]:bioperator_levels = [BiOperatorLevel] [
        BiOperatorLevel [[BiOperator] [
            BiOperator ["=", false], BiOperator ["+=", false],
            BiOperator ["-=", false], BiOperator ["*=", false],
            BiOperator ["/=", false], BiOperator ["%=", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["&&", true], BiOperator ["||", true]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator [">", false], BiOperator ["<", false],
            BiOperator [">=", false], BiOperator ["<=", false],
            BiOperator ["==", false], BiOperator ["!=", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["+", false], BiOperator ["-", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["*", false], BiOperator ["/", false],
            BiOperator ["~/", false], BiOperator ["%", false]
        ]],
        BiOperatorLevel [[BiOperator] [
            BiOperator ["**", false]
        ]],
    ];
    bioperator_levels_cache = bioperator_levels;
    return bioperator_levels;
}

FunctionGroupCall?#try match group in [AvailableFuncs:funcs] state: [ParseState:state] {
    W:start = [state].cur_start;
    L:index = state.index;
    // STEP: check for function calls
    for FunctionGroup:group in funcs.groups {
        [ParseState]:arg_substates = [ParseState] [];
        Bool:matched = true;
        for $TemplateSegment:segment in group.template.segments {
            if [state].is_at_end {
                matched = false;
                break;
            };
            given segment as IdentifierTemplateSegment:identifier_segment {
                if ![[state].try_read_ident] equals [identifier_segment.text#Str?] {
                    matched = false;
                    break;
                };
            } given segment as ArgumentTemplateSegment:argument_segment {
                if [state].cur_id != T_SQUARE_GROUP {
                    matched = false;
                    break;
                };
                [arg_substates].append[[state].cur_substate];
            } given segment as SymbolTemplateSegment:symbol_segment {
                if [state].cur_id != symbol_segment.symbol {
                    matched = false;
                    break;
                };
            } else {
                abort ["Unknown TemplateSegment {}" % segment];
            };
            [state].consume;
        };
        if matched {
            return FunctionGroupCall [
                start, [state].last_end, group, arg_substates
            ];
        };
        state.index = index;
    };
    return null;
}

Str#stringify expr list types_ [[$Expression]:exprs] {
    Str:result = Str [];
    for $Expression:expr in exprs {
        if result {
            [result].extend[", "];
        };
        [result].extend[[expr.type_].stringify];
    };
    return result;
}

[FunctionDeclaration]#get best funcs in [[FunctionDeclaration]:funcs] with args [[$Expression]:args] {
    [W]:func_scores = [W]*[funcs].len;
    for L:i enumerating args {
        $Type_:arg_type_ = args[i].type_;

        for L:j enumerating funcs {
            if [arg_type_] is equal to [funcs[j].parameters[i].type_] {
                func_scores[j] += 1;
            };
        };
    };

    [FunctionDeclaration]:remaining_funcs = [FunctionDeclaration] [];
    W:max_score = 0;
    for L:j enumerating funcs {
        W:func_score = func_scores[j];
        if func_score == max_score {
            [remaining_funcs].append[funcs[j]];
        } elif func_score > max_score {
            max_score = func_score;
            remaining_funcs = [FunctionDeclaration] [funcs[j]];
        };
    };
    funcs = remaining_funcs;

    if [funcs].len == 1 {
        return funcs;
    };

    [FunctionDeclaration]:best_funcs = [FunctionDeclaration] [];
    for L:j enumerating funcs {
        Bool:any_greater = false;
        for L:k enumerating funcs {
            if j == k {
                continue;
            };
            for L:i enumerating args {
                $Type_:other_type_ = funcs[k].parameters[i].type_;
                $Type_:this_type_ = funcs[j].parameters[i].type_;
                if [other_type_] is greater than [this_type_] {
                    any_greater = true;
                    break;
                };
            };
            if any_greater {
                break;
            };
        };
        if !any_greater {
            [best_funcs].append[funcs[j]];
        };
    };

    return best_funcs;
}

FunctionCallExpression?#resolve [FunctionGroupCall:func_group_call] state: [ParseState:state] ctx: [ExprContext:ctx] {
    [$Expression]:args = [$Expression] [];
    for ParseState:arg_substate in func_group_call.arg_substates {
        given parse expr [arg_substate] ctx: [ctx] as $Expression:arg {
            [args].append[arg];
        } else {
            return null;
        };
        if ![arg_substate].require_finished why: ["Expected ']' before {}"] {
            return null;
        };
    };

    [FunctionDeclaration]:group_funcs = func_group_call.group.funcs;
    [FunctionDeclaration]:func_options = [FunctionDeclaration] [];
    for FunctionDeclaration:group_func in group_funcs {
        Bool:matches = true;
        for L:i enumerating args {
            $Type_:param_type_ = group_func.parameters[i].type_;
            $Type_:arg_type_ = args[i].type_;
            if ![arg_type_] is convertible to [arg_type_] {
                matches = false;
                break;
            };
        };
        if matches {
            [func_options].append[group_func];
        };
    };

    Str:plural = "";
    if [args].len == 1 {
        plural = "s";
    };

    if !func_options {
        Str:msg = "Types supplied to function do not match any overload:
Got type{}: {}
Expected type{}: {}"
            % plural % stringify expr list types_ [args] % plural
            % stringify funcs param type_ options [group_funcs];
        [state].error_at[func_group_call] msg: [msg];
        return null;
    };

    [FunctionDeclaration]:best_funcs = get best funcs
        in [func_group_call.group.funcs] with args [args];

    if [best_funcs].len == 1 {
        FunctionDeclaration:chosen_func = best_funcs[0];
        return FunctionCallExpression [
            func_group_call.start_index, func_group_call.end_index,
            chosen_func.ret_type_, chosen_func, args
        ];
    } else {
        Str:msg = "Ambiguous function call:
Got type{}: {}
Please clarify between functions that take the types:
{}"
            % plural % stringify expr list types_ [args]
            % stringify funcs param type_ options [best_funcs];
        [state].error_at[func_group_call] msg: [msg];
        return null;
    };
}

$Expression?#parse expr term inner [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].require_more why: ["Expected expression"] {
        return null;
    };

    // STEP: check for function calls
    given try match group in [ctx.mod_ctx.avaliable_funcs] state: [state]
    as FunctionGroupCall:func_group_call {
        return resolve [func_group_call] state: [state] ctx: [ctx];
    };

    W:start = [state].cur_start;
    [state].consume;

    // STEP: check for constants
    if [state].last_id == T_INT {
        Z64:val = [[state].last_data#IntTokenData?].unwrap.val;
        $NumericType_:type_ = ZType_ [64];
        if val > 0 {
            if val > ~[0#W32]#Z64 {
                type_ = WType_ [64];
            } else {
                type_ = WType_ [32];
            };
        } else {
            if val > -[1#Z64] << [31] {
                type_ = ZType_ [32];
            };
        };
        return IntConstantExpression [
            start, [state].last_end, type_, val
        ];
    } elif [state].last_id == T_FLOAT {
        R:val = [[state].last_data#FloatTokenData?].unwrap.val;
        return FloatConstantExpression [
            start, [state].last_end, RType_ [64], val
        ];
    } elif [state].last_id == T_BYTE {
        Byte:val = [[state].last_data#ByteTokenData?].unwrap.val;
        return ByteConstantExpression [
            start, [state].last_end, ByteType_ [8], val
        ];
    } elif [state].last_id == T_STR {
        Str:val = [[state].last_data#StrTokenData?].unwrap.val;
        return StrConstantExpression [
            start, [state].last_end, Str_, val
        ];

    // STEP: check for prefix operators
    } elif [state].last_id == '-' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            Str:template = "'-' expects a number, found {}";
            if !expect [operand] satisfies [NumericType_Criteria []] state: [state] template: [template] {
                return null;
            };
            $Type_:type_ = operand.type_;
            given type_ as $UnsignedIntegerType_:uint_type_ {
                type_ = ZType_ [uint_type_.bits];
            };
            given operand as IntConstantExpression:int_const {
                int_const.type_ = type_;
                int_const.val *= -1;
                int_const.start_index = start;
                return int_const;
            } given operand as FloatConstantExpression:float_const {
                float_const.val *= -1;
                float_const.start_index = start;
                return float_const;
            };
            return NegateExpression [
                start, [state].last_end, type_, operand
            ];
        } else {
            return null;
        };
    } elif [state].last_id == '!' {
        given parse expr term inner [state] ctx: [ctx] as $Expression:operand {
            return NotExpression [
                start, [state].last_end, BoolType_ [1], operand
            ];
        } else {
            return null;
        };

    // STEP: check for parenthesis groups
    } elif [state].last_id == T_PAREN_GROUP {
        given parse expr [[state].last_substate] ctx: [ctx] as $Expression:inner {
            return ParenExpression [start, [state].last_end, inner.type_, inner];
        } else {
            return null;
        };

    // STEP: check for exprs starting with an identifier
    } elif [state].last_id == T_IDENT {
        Str:ident = [[state].last_data].read_identifier;
        return parse ident [ident] expr [state] ctx: [ctx];
    };

    [state].unconsume;
    [state].error_about_current msg: ["Expected expression"];
    return null;
}

InstantiationExpression?#parse instantiation ident: [Str:ident] state: [ParseState:state] ctx: [ExprContext:ctx] {
    // this function is to be called when an instantiation has been detected,
    // but the curly group has not been consumed

    Struct_?:maybe_struct = get struct named [ident] from [ctx.mod_ctx.type__ctx];
    if !maybe_struct {
        Str:msg = "Cannot instantiate nonexistent struct {}" % ident;
        [state].error_at_previous msg: [msg];
    };
    Struct_:struct_ = [maybe_struct].unwrap;
    [Field]:fields = [struct_].all_fields;

    W:start = [state].last_start;
    [state].consume; // eat the curly group

    ParseState:substate = [state].last_substate;

    [$Expression]:field_vals = [$Expression] [];

    while ![substate].is_at_end {
        Field?:maybe_field = fields[[field_vals].len]?;

        W:field_val_start = [substate].cur_start;

        given [substate].try_read_ident as Str:possibly_label {
            // this could be a label, or it could be just a normal
            // function call, variable, etc
            [substate].consume;
            if ![substate].is_at_end && [substate].cur_id == ':' {
                // yep, it's a label
                given maybe_field as Field:field {
                    if ![field.name] equals [possibly_label] {
                        Str:msg = "Expected field label to be '{}'"
                            % field.name;
                        [substate].error_at_previous msg: [msg];
                    };
                };
                // eat the ':'
                [substate].consume;
            } else {
                // nope, not a label; unconsume the identifier
                [substate].unconsume;
            };
        };

        $Expression?:maybe_val = parse expr [substate] ctx: [ctx];
        if !maybe_val {
            return null;
        };
        $Expression:val = [maybe_val].unwrap;

        given maybe_field as Field:field {
            if ![val.type_] is convertible to [field.type_] {
                Str:msg = "Expected value of type {} for field '{}', found value of type {}"
                    % [field.type_].stringify % field.name % [val.type_].stringify;
                [substate].error_at[val] msg: [msg];
            };
        } else {
            [substate].error_between [field_val_start] and [[substate].last_end]
                msg: ["Too many values for instantiation"];
        };
        [field_vals].append[val];

        if ![substate].is_at_end {
            [substate].consume[','];
        };
    };

    if [field_vals].len < [fields].len {
        L:missing_count = [fields].len - [field_vals].len;
        Str:plural = "";
        if missing_count > 1 {
            plural = "s";
        };
        Str:field_names = Str [];
        for Field:field in fields from [field_vals].len {
            if field_names {
                [field_names].extend[", "];
            };
            [field_names].extend[field.name];
        };
        Str:msg = "Missing {} value{} for field{} {}"
            % missing_count % plural % plural % field_names;
        [substate].error_at_end msg: [msg];
    };

    return InstantiationExpression [
        start, [state].last_end, StructType_ [struct_], struct_, field_vals
    ];
}

VariableDeclarationExpression?#parse var decl ident: [Str:ident] state: [ParseState:state] ctx: [ExprContext:ctx] {
    // this function is to be called when a var decl has been detected,
    // but the ':' has not been consumed

    W:start = [state].last_start;
    [state].consume; // eat the ':'

    $Type_?:maybe_type_ = null;
    if [state].cur_id != '=' {
        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:type_ {
            maybe_type_ = type_;
        } else {
            return null;
        };
    };
    if ![state].consume['='] {
        return null;
    };

    $Expression?:maybe_initializer = null;

    given parse expr [state] ctx: [ctx] as $Expression:initializer {
        maybe_initializer = initializer;
        given maybe_type_ as $Type_:var_type_ {
            if ![initializer.type_] is convertible to [var_type_] {
                Str:msg = "Cannot assign value of type {} to variable wit type {}"
                    % [initializer.type_].stringify % [var_type_].stringify;
                [state].error_at[initializer] msg: [msg];
            };
        } else {
            given initializer.type_ as NullType_:null_type_ {
                [state].error_at[initializer]
                    msg: ["Variable type cannot be inferred to initializer type Null"];
            };
            maybe_type_ = initializer.type_;
        };
    };

    given maybe_type_ as $Type_:var_type_ {
        ScopeVar:var = add var [ident] type_: [[maybe_type_].unwrap] to: [ctx];
        given maybe_initializer as $Expression:initializer {
            return VariableDeclarationExpression [
                start, [state].last_end, NullType_ [], var, initializer
            ];
        };
    };

    return null;
}

WhileExpression?#parse while_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    ExprContext:cond_ctx = [ctx].new_scope;
    $Expression?:maybe_cond = parse expr [state] ctx: [cond_ctx];
    if !maybe_cond {
        return null;
    };
    $Expression:cond = [maybe_cond].unwrap;

    ExprContext:block_ctx = [ctx].new_scope;
    LoopCtx:loop_ctx = LoopCtx [
        [BreakExpression] [], [ContinueExpression] [], block_ctx.scope
    ];
    block_ctx.loop_ctx = loop_ctx;
    Block?:maybe_block = parse block [state] ctx: [block_ctx];
    if !maybe_block {
        return null;
    };
    Block:block = [maybe_block].unwrap;

    $Type_?:maybe_base_type_ = null;

    Block?:maybe_else_block = null;
    if [[state].try_read_ident] equals ["else"#Str?] {
        [state].consume;
        given parse block [state] ctx: [ctx] as Block:else_block {
            maybe_else_block = else_block;
            maybe_base_type_ = else_block.type_;
        } else {
            return null;
        };
    };

    if [cond].is_truthy_const {
        maybe_base_type_ = NeverType_ [];
    };

    $Type_:type_ = NullType_ [];
    given maybe_base_type_ as $Type_:base_type_ {
        type_ = base_type_;
        for BreakExpression:break_ in loop_ctx.breaks {
            given common type_ between [type_] and [break_.result.type_]
            as $Type_:common_type_ {
                type_ = common_type_;
            } else {
                type_ = NullType_ [];
                break;
            };
        };
    };

    return WhileExpression [
        start, [state].last_end, type_,
        cond, cond_ctx.scope,
        block, maybe_else_block
    ];
}

IfExpression?#parse if_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    [IfBranch]:branches = [IfBranch] [];

    $Type_?:maybe_type_ = NeverType_ [];

    Bool:has_else = false;
    while true {
        ExprContext:cond_ctx = [ctx].new_scope;
        $Expression?:maybe_cond = parse expr [state] ctx: [cond_ctx];
        if !maybe_cond {
            return null;
        };
        $Expression:cond = [maybe_cond].unwrap;

        ctx = [cond_ctx].new_scope;
        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [block.type_];
        };

        [branches].append[IfBranch [cond, cond_ctx.scope, block]];

        Str?:next_ident = [state].try_read_ident;

        if [next_ident] equals ["elif"#Str?] {
            [state].consume;
            continue;
        } elif [next_ident] equals ["else"#Str?] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Block?:maybe_else_block = null;
    if has_else {
        ctx = [ctx].new_scope;
        maybe_else_block = parse block [state] ctx: [ctx];
        if !maybe_else_block {
            return null;
        };
        Block:else_block = [maybe_else_block].unwrap;

        given maybe_type_ as $Type_:type_ {
            maybe_type_ = common type_ between [type_] and [else_block.type_];
        };
    } else {
        maybe_type_ = null;
    };

    $Type_:type_ = [maybe_type_] || [NullType_ []];

    return IfExpression [
        start, [state].last_end, type_, branches, maybe_else_block
    ];
}

SubVarDeclNode?#parse explicit var decl [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].cur_start;

    if ![state].consume[T_IDENT] name: ["variable name"] {
        return null;
    };
    Str:var_ident = [[state].last_data].read_identifier;

    if ![state].consume[':'] {
        return null;
    };

    $Type_?:maybe_type_ = parse type_ state: [state]
        ctx: [ctx.mod_ctx.type__ctx];
    if !maybe_type_ {
        return null;
    };
    $Type_:type_ = [maybe_type_].unwrap;

    return SubVarDeclNode [
        start, [state].last_end, add var [var_ident] type_: [type_] to: [ctx]
    ];
}

$Expression?#parse given_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    $Expression?:maybe_scrutinee = parse expr [state] ctx: [ctx];
    if !maybe_scrutinee {
        return null;
    };
    $Expression:scrutinee = [maybe_scrutinee].unwrap;

    given [state].try_read_ident as Str:clause_name {
        if [clause_name] equals ["as"] {
            return parse given_ as [state] ctx: [ctx] start: [start]
                scrutinee: [scrutinee];
        } elif [clause_name] equals ["is"] {
            return parse given_ is [state] ctx: [ctx] start: [start]
                scrutinee: [scrutinee];
        };
    };
    [state].error_at_current msg: ["Expected 'as' or 'is'"];
    return null;
}

GivenAsExpression?#parse given_ as [ParseState:state] ctx: [ExprContext:ctx] start: [W:start] scrutinee: [$Expression:scrutinee] {
    [GivenAsArm]:arms = [GivenAsArm] [];

    $Type_?:maybe_result_type_ = NeverType_ [];

    Bool:has_else = false;

    while true {
        [state].consume; // eat the 'as'

        ctx = [ctx].new_scope;

        SubVarDeclNode?:maybe_var_decl = parse explicit var decl [state] ctx: [ctx];
        if !maybe_var_decl {
            return null;
        };
        SubVarDeclNode:var_decl = [maybe_var_decl].unwrap;

        $Type_:var_type_ = var_decl.var.type_;
        if ![scrutinee.type_] is castable to [OptionalType_ [var_type_]] {
            Str:msg = "Scrutinee of type {} can never be {}"
                % [scrutinee.type_].stringify % [var_type_].stringify;
            [state].error_at[var_decl] msg: [msg];
        };

        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_result_type_ as $Type_:result_so_far {
            maybe_result_type_= common type_ between
                [result_so_far] and [block.type_];
        };

        [arms].append[GivenAsArm [var_decl.var, block]];

        Str?:ident = [state].try_read_ident;
        if [ident] equals ["as"#Str?] {
            continue;
        } elif [ident] equals ["is"#Str?] {
            Str:msg = "Given with 'as' clause cannot have 'is' clause";
            [state].error_at_current msg: [msg];
            return null;
        } elif [ident] equals ["else"#Str?] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Bool:else_never = false;
    Block?:maybe_else_block = null;

    if has_else {
        if [[state].try_read_ident] equals ["never"#Str?] {
            [state].consume;
            else_never = true;
        } else {
            maybe_else_block = parse block [state] ctx: [ctx];
            if !maybe_else_block {
                return null;
            };
            Block:else_block = [maybe_else_block].unwrap;

            given maybe_result_type_ as $Type_:result_so_far {
                maybe_result_type_= common type_ between
                    [result_so_far] and [else_block.type_];
            };
        };
    } else {
        maybe_result_type_ = null;
    };

    if else_never {
        [$Type_]:arm_types_ = [$Type_] [];
        for GivenAsArm:arm in arms {
            [arm_types_].append[arm.var.type_];
        };
        if !types_ [arm_types_] encompass [scrutinee.type_] {
            Str:msg = "Given arms possibly do not exhaust scrutinee type {}"
                % [scrutinee.type_].stringify;
            [state].error_at_previous msg: [msg];
        };
    };

    return GivenAsExpression [
        start, [state].last_end, [maybe_result_type_] || [NullType_ []],
        scrutinee, arms, maybe_else_block, else_never
    ];
}

GivenIsExpression?#parse given_ is [ParseState:state] ctx: [ExprContext:ctx] start: [W:start] scrutinee: [$Expression:scrutinee] {
    [GivenIsArm]:arms = [GivenIsArm] [];

    $Type_?:maybe_result_type_ = NeverType_ [];

    Bool:has_else = false;

    while true {
        [state].consume; // eat the 'is'

        $Expression?:maybe_target_expr = parse expr [state] ctx: [ctx];
        if !maybe_target_expr {
            return null;
        };
        $Expression:target_expr = [maybe_target_expr].unwrap;
        $ConstantExpression?:maybe_target = target_expr#$ConstantExpression?;
        if !maybe_target {
            [state].error_at[target_expr] msg: ["Expected constant"];
            return null;
        };
        $ConstantExpression:target = [maybe_target].unwrap;

        if ![target.type_] is convertible to [scrutinee.type_] {
            Str:msg = "Target not convertible to scrutinee type {}"
                % [scrutinee.type_].stringify;
            [state].error_at[target_expr] msg: [msg];
            return null;
        };

        Block?:maybe_block = parse block [state] ctx: [ctx];
        if !maybe_block {
            return null;
        };
        Block:block = [maybe_block].unwrap;

        given maybe_result_type_ as $Type_:result_so_far {
            maybe_result_type_= common type_ between
                [result_so_far] and [block.type_];
        };

        [arms].append[GivenIsArm [target, block]];

        Str?:ident = [state].try_read_ident;
        if [ident] equals ["as"#Str?] {
            Str:msg = "Given with 'is' clause cannot have 'as' clause";
            [state].error_at_current msg: [msg];
            return null;
        } elif [ident] equals ["is"#Str?] {
            continue;
        } elif [ident] equals ["else"#Str?] {
            [state].consume;
            has_else = true;
        };
        break;
    };

    Block?:maybe_else_block = null;

    if has_else {
        if [[state].try_read_ident] equals ["never"#Str?] {
            Str:msg = "'else never' is not allowed for given blocks with 'is' clauses";
            [state].error_at_current msg: [msg];
        };
        maybe_else_block = parse block [state] ctx: [ctx];
        if !maybe_else_block {
            return null;
        };
        Block:else_block = [maybe_else_block].unwrap;

        given maybe_result_type_ as $Type_:result_so_far {
            maybe_result_type_= common type_ between
                [result_so_far] and [else_block.type_];
        };
    } else {
        maybe_result_type_ = null;
    };

    return GivenIsExpression [
        start, [state].last_end, [maybe_result_type_] || [NullType_ []],
        scrutinee, arms, maybe_else_block
    ];
}

ForExpression?#parse for_ [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;

    ExprContext:block_ctx = [ctx].new_scope;
    LoopCtx:loop_ctx = LoopCtx [
        [BreakExpression] [], [ContinueExpression] [], block_ctx.scope
    ];
    block_ctx.loop_ctx = loop_ctx;

    SubVarDeclNode?:maybe_var_decl = parse explicit var decl [state] ctx: [block_ctx];
    if !maybe_var_decl {
        return null;
    };
    SubVarDeclNode:var_decl = [maybe_var_decl].unwrap;

    ToForClause?:maybe_to = null;
    FromForClause?:maybe_from = null;
    StepForClause?:maybe_step = null;
    InForClause?:maybe_in = null;
    EnumeratingForClause?:maybe_enumerating = null;
    WhereForClause?:maybe_where = null;
    MapForClause?:maybe_map = null;
    InplaceForClause?:maybe_inplace = null;

    while ![state].is_at_end && [state].cur_id != T_CURLY_GROUP {
        if ![state].consume[T_IDENT] name: ["for clause name"] {
            return null;
        };

        W:clause_start = [state].last_start;

        Str:clause_name = [[state].last_data].read_identifier;
        switch clause_name
        ("to") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_to = ToForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("from") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_from = FromForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("step") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_step = StepForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("in") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_in = InForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("enumerating") {
            ExprContext:clause_ctx = [ctx].new_scope;
            given parse expr [state] ctx: [clause_ctx] as $Expression:val {
                maybe_enumerating = EnumeratingForClause [
                    clause_start, [state].last_end, val, clause_ctx.scope
                ];
            } else {return null;};
        }
        ("where") {
            given parse expr [state] ctx: [block_ctx] as $Expression:val {
                maybe_where = WhereForClause [
                    clause_start, [state].last_end, val, block_ctx.scope
                ];
            } else {return null;};
        }
        ("map") {
            maybe_map = MapForClause [clause_start, [state].last_end];
        }
        ("inplace") {
            maybe_inplace = InplaceForClause [clause_start, [state].last_end];
        }
        {
            [state].error_at_previous
                msg: ["Invalid for loop clause name '{}'" % clause_name];
            return null;
        };
    };

    Block?:maybe_block = parse block [state] ctx: [block_ctx];
    if !maybe_block {
        return null;
    };
    Block:block = [maybe_block].unwrap;

    Block?:maybe_else_block = null;
    if [[state].try_read_ident] equals ["else"#Str?] {
        [state].consume;
        ExprContext:else_ctx = [ctx].new_scope;
        maybe_else_block = parse block [state] ctx: [else_ctx];
        if !maybe_else_block {
            return null;
        };
    };

    $Type_:idx_type_ = var_decl.var.type_;
    given maybe_in as InForClause:in_clause {
        idx_type_ = WType_ [64];
    };

    given maybe_in as InForClause:in_clause {
        given maybe_enumerating as EnumeratingForClause:enumerating_clause {
            Str:msg = "For loops cannot have both an 'in' and an 'enumerating' clause";
            [state].error_at[in_clause] msg: [msg];
        };
    } else {
        if ![var_decl.var.type_].is_int {
            [state].error_at[var_decl]
                msg: ["Loop variable type must be an integer"];
        };
    };

    given maybe_enumerating as EnumeratingForClause:enumerating_clause {
        given maybe_to as ToForClause:to_clause {
            Str:msg = "For loops cannot have both a 'to' and an 'enumerating' clause";
            [state].error_at[to_clause] msg: [msg];
        };
    };

    given maybe_where as WhereForClause:where_clause {
        given where_clause.val.type_ as NullType_:null_type_ {
            [state].error_at[where_clause]
                msg: ["The 'where' clause must hold a condition, this expression has type Null"];
        };
    };

    if !maybe_to && !maybe_in && !maybe_enumerating {
        [state].error_between [start] and [[state].last_end]
            msg: ["For loops must have a 'to', 'in', or 'enumerating' clause"];
    };

    $Type_?:maybe_arr_type_ = null;

    given maybe_to as ToForClause:to_clause {
        if ![to_clause.val.type_] is convertible to [idx_type_] {
            Str:msg = "'to' clause value type must be convertible to {}, found type {}"
                % [idx_type_].stringify % [to_clause.val.type_].stringify;
            [state].error_at[to_clause] msg: [msg];
        };
    };
    given maybe_from as FromForClause:from_clause {
        if ![from_clause.val.type_] is convertible to [idx_type_] {
            Str:msg = "'from' clause value type must be convertible to {}, found type {}"
                % [idx_type_].stringify % [from_clause.val.type_].stringify;
            [state].error_at[from_clause] msg: [msg];
        };
    };
    given maybe_step as StepForClause:step_clause {
        if ![step_clause.val.type_].is_int {
            Str:msg = "'step' clause value must be an integer, found value of type {}"
                % [step_clause.val.type_].stringify;
            [state].error_at[step_clause] msg: [msg];
        };
    };
    given maybe_in as InForClause:in_clause {
        $Type_:target_type_ = Array_ of [var_decl.var.type_];
        if [in_clause.val.type_] is convertible to [target_type_] {
            maybe_arr_type_ = in_clause.val.type_;
        } else {
            Str:msg = "'in' clause value type must be convertible to {}, found {}"
                % [target_type_].stringify % [in_clause.val.type_].stringify;
            [state].error_at[in_clause] msg: [msg];
        };
    };
    given maybe_enumerating as EnumeratingForClause:enumerating_clause {
        GenericType_Criteria:criteria = GenericType_Criteria [
            "Array", [$Type_Criteria] [AnyType_Criteria []]
        ];
        if [enumerating_clause.val.type_].satisfies[criteria] {
            maybe_arr_type_ = enumerating_clause.val.type_;
        } else {
            Str:msg = "'enumerating' clause value must be an Array, found type {}"
                % [enumerating_clause.val.type_].stringify;
            [state].error_at[enumerating_clause] msg: [msg];
        };
    };
    given maybe_inplace as InplaceForClause:inplace_clause {
        if !maybe_in && !maybe_enumerating {
            Str:msg = "For loops with an 'inplace' clause require an 'in' or 'enumerating' clause";
            [state].error_at[inplace_clause] msg: [msg];
        };

        given maybe_map as MapForClause:map_clause {
            Str:msg = "For loops cannot have both an 'inplace' and a 'map' clause";
            [state].error_at[inplace_clause] msg: [msg];
        };

        given maybe_arr_type_ as $Type_:arr_type_ {
            $Type_:elem_type_ = [arr_type_#GenericType_?].unwrap.generics[0];
            if ![block.type_] is convertible to [elem_type_] {
                Str:msg = "Expected block to produce result convertible to {}, found result of type {}"
                    % [elem_type_].stringify % [block.type_].stringify;
                [state].error_at[[block.lines].at[-1]] msg: [msg];
            };
        };
    };

    $Type_:result_type_ = NullType_ [];

    if maybe_map || maybe_inplace {
        if maybe_map {
            result_type_ = Array_ of [block.type_];
        };

        for BreakExpression:break_expr in loop_ctx.breaks {
            if !(break_expr.result.type_#NullType_?) {
                Str:msg = "Breaks in for loops with 'map' or 'inplace' clauses must produce Null, got type {}"
                    % [break_expr.result.type_].stringify;
                [state].error_at[break_expr] msg: [msg];
            };
        };

        given maybe_else_block as Block:else_block {
            if !(else_block.type_#NullType_?) {
                Str:msg = "Else blocks on for loops with 'map' or 'inplace' clauses must produce Null, got type {}"
                    % [else_block.type_].stringify;
                [state].error_at[[else_block.lines].at[-1]] msg: [msg];
            };
        };
    } else {
        given maybe_else_block as Block:else_block {
            result_type_ = else_block.type_;
            for BreakExpression:break_ in loop_ctx.breaks {
                given common type_ between [result_type_] and [break_.result.type_]
                as $Type_:common_type_ {
                    result_type_ = common_type_;
                } else {
                    result_type_ = NullType_ [];
                    break;
                };
            };
        };
    };

    return ForExpression [
        start, [state].last_end, result_type_, var_decl.var,
        maybe_to, maybe_from, maybe_step, maybe_in, maybe_enumerating,
        maybe_where, maybe_map, maybe_inplace,
        block, maybe_else_block
    ];
}

$Expression?#parse ident [Str:ident] expr [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].last_start;
    switch ident
    ("null") {
        return NullExpression [
            start, [state].last_end, NullType_ []
        ];
    }
    ("return") {
        W:pos = [state].last_end + 1;
        $Expression:returnee = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_returnee {
                returnee = explicit_returnee;
            } else {
                return null;
            };
        };
        if ![returnee.type_] is convertible to [ctx.func_decl.ret_type_] {
            Str:msg = "Value of type {} not convertible to the return type, {}"
                % [returnee.type_].stringify % [ctx.func_decl.ret_type_].stringify;
            [state].error_at[returnee] msg: [msg];
        };
        return ReturnExpression [
            start, [state].last_end, NeverType_ [], returnee,
            ScopeSection [ctx.scope.chain, ctx.scope.func_chain_end]
        ];
    }
    ("break") {
        W:pos = [state].last_end + 1;
        $Expression:result = NullExpression [pos, pos, NullType_ []];
        if ![state].is_at_end && [state].cur_id != ';' {
            given parse expr [state] ctx: [ctx] as $Expression:explicit_result {
                result = explicit_result;
            } else {
                return null;
            };
        };
        BreakExpression:break_ = BreakExpression [
            start, [state].last_end, NeverType_ [], result,
            // create a dummy and incorrect unwind section
            ScopeSection [ctx.scope.chain, ctx.scope.scope_chain_end]
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            break_.unwind_section.terminator = loop_ctx.scope.scope_chain_end;
            [loop_ctx.breaks].append[break_];
        } else {
            [state].error_at[break_]
                msg: ["'break' keyword invalid when not inside loop"];
        };
        return break_;
    }
    ("continue") {
        ContinueExpression:continue_ = ContinueExpression [
            start, [state].last_end, NeverType_ [],
            // create a dummy and incorrect unwind section
            ScopeSection [ctx.scope.chain, ctx.scope.scope_chain_end]
        ];
        given ctx.loop_ctx as LoopCtx:loop_ctx {
            continue_.unwind_section.terminator = loop_ctx.scope.scope_chain_end;
            [loop_ctx.continues].append[continue_];
        } else {
            [state].error_at[continue_]
                msg: ["'continue' keyword invalid when not inside loop"];
        };
        return continue_;
    }
    ("true") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], true
        ];
    }
    ("false") {
        return BoolConstantExpression [
            start, [state].last_end, BoolType_ [1], false
        ];
    }
    ("while") {
        return parse while_ [state] ctx: [ctx];
    }
    ("if") {
        return parse if_ [state] ctx: [ctx];
    }
    ("given") {
        return parse given_ [state] ctx: [ctx];
    }
    ("for") {
        return parse for_ [state] ctx: [ctx];
    }
    { // it's a variable OR an instantiation
        if ![state].is_at_end && [state].cur_id == T_CURLY_GROUP {
            return parse instantiation ident: [ident] state: [state] ctx: [ctx];
        };
        if ![state].is_at_end && [state].cur_id == ':' {
            return parse var decl ident: [ident] state: [state] ctx: [ctx];
        };
        given lookup variable [ident] in [ctx.scope.chain] as ScopeVar:var {
            return VariableExpression [
                start, [state].last_end, var.type_, var
            ];
        } else {
            [state].error_at_previous
                msg: ["The name '{}' cannot be found here" % ident];
            return null;
        };
    };
}

$Expression?#assign [$Expression:value] to [$Expression:recipient] state: [ParseState: state] {
    if ![value.type_] is convertible to [recipient.type_] {
        Str:msg = "Cannot assign value of type {} to recipient expecting a type convertible to {}"
            % [value.type_].stringify % [recipient.type_].stringify;
        [state].error_at[value] msg: [msg];
    };
    given recipient as VariableExpression:var_expr {
        return VariableAssignmentExpression [
            recipient.start_index, value.end_index, NullType_ [],
            var_expr.var, value
        ];
    } given recipient as FieldAccessExpression:field_access_expr {
        return FieldAssignmentExpression [
            recipient.start_index, value.end_index, NullType_ [],
            field_access_expr.struct_, field_access_expr.field_idx, value
        ];
    } else {
        [state].error_at[recipient] msg: ["Cannot assign to this expression"];
        return null;
    };
}

$Expression?#parse expr postfix [ParseState:state] on: [$Expression:base] ctx: [ExprContext:ctx] {
    if [state].is_at_end {
        return base;
    };

    if [state].cur_id == '.' {
        [state].consume;

        if ![state].consume[T_IDENT] name: ["field name"] {
            [state].unconsume;
            return null;
        };

        Str:field_name = [[state].last_data].read_identifier;

        Struct_?:maybe_struct = struct_ of [base.type_];
        if !maybe_struct {
            Str:msg = "Cannot access field of non-struct {}"
                % [base.type_].stringify;
            [state].error_at[base] msg: [msg];
            return null;
        };
        Struct_:struct = [maybe_struct].unwrap;

        [Field]:fields = [struct].all_fields;
        L?:maybe_field_idx = [fields].find_field name: [field_name];
        if !maybe_field_idx {
            Str:msg = "Struct {} has no field {}" % struct.name % field_name;
            [state].error_at_previous msg: [msg];
            return null;
        };
        L:field_idx = [maybe_field_idx].unwrap;
        Field:field = fields[field_idx];

        return FieldAccessExpression [
            base.start_index, [state].last_end, field.type_, base, field_idx
        ];

    } elif [state].cur_id == '#' {
        [state].consume;

        given parse type_ state: [state] ctx: [ctx.mod_ctx.type__ctx]
        as $Type_:to_type_ {
            if ![base.type_] is castable to [to_type_] {
                Str:msg = "Cannot cast value of type {} to type {}"
                    % [base.type_].stringify % [to_type_].stringify;
                [state].error_at[base] msg: [msg];
            };
            return CastExpression [
                base.start_index, [state].last_end, to_type_, base
            ];
        } else {
            return null;
        };
    };

    return base;
}

$Expression?#parse expr term [ParseState:state] ctx: [ExprContext:ctx] {
    given parse expr term inner [state] ctx: [ctx] as $Expression:expr {
        while true {
            given parse expr postfix [state] on: [expr] ctx: [ctx]
            as $Expression:postfix_expr {
                if expr == postfix_expr {
                    return expr;
                };
                expr = postfix_expr;
            } else {
                return null;
            };
        };
    } else {
        return null;
    };
}

BiOperator?#match [BiOperatorLevel:level] against [ParseState:state] {
    if [state].is_at_end {
        return null;
    };
    L:index = state.index;
    for BiOperator:operator in level.operators {
        Bool:failed = false;
        for Byte:byte in operator.spelling {
            if [state].cur_id != byte {
                failed = true;
                break;
            };
            [state].consume;
        };
        if !failed && [state].cur_id != '=' {
            return operator;
        };
        state.index = index;
    };
    return null;
}

Bool#expect [$Expression:expr] satisfies [$Type_Criteria:criteria] state: [ParseState:state] template: [Str:template] {
    if [expr.type_].satisfies[criteria] {
        return true;
    };
    [state].error_at[expr] msg: [template % [expr.type_].stringify];
    return false;
}

Bool#expect numeric [$Expression:a] and [$Expression:b] op: [BiOperator:operator] state: [ParseState:state] {
    Str:template = "'{}' expects a number, found {}" % operator.spelling % "{}";
    $Type_Criteria:criteria = NumericType_Criteria [];
    return
        expect [a] satisfies [criteria] state: [state] template: [template]
        && expect [b] satisfies [criteria] state: [state] template: [template];
}

Bool#expect comparable [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    if !types_ [a.type_] and [b.type_] are compatible {
        Str:msg = "Cannot compare types {} and {}"
            % [a.type_].stringify % [b.type_].stringify;
        [state].error_at [[$Node] [a, b]] msg: [msg];
        return false;
    };
    return true;
}

$Type_?#type_ for_ [BiOperator:operator] on [$Expression:a] and [$Expression:b] state: [ParseState:state] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_:at = a.type_;
    $Type_:bt = b.type_;

    Str:spelling = operator.spelling;
    if ([spelling] equals ["&&"]) || ([spelling] equals ["||"]) {
        return BoolType_ [1];
    } elif ([spelling] equals [">"]) || ([spelling] equals ["<"])
        || ([spelling] equals [">="]) || ([spelling] equals ["<="]) {
        expect numeric [a] and [b] op: [operator] state: [state];
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["=="]) || ([spelling] equals ["!="]) {
        expect comparable [a] and [b] state: [state];
        return BoolType_ [1];
    } elif ([spelling] equals ["+"]) || ([spelling] equals ["-"])
        || ([spelling] equals ["*"]) || ([spelling] equals ["%"]) {
        if ([spelling] equals ["%"]) && ([at] is equal to [Str_]) {
            return Str_;
        };
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["/"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        W:bits = 64;
        given at as RType_:at_R {
            bits = at_R.bits;
        };
        return RType_ [bits];
    } elif [spelling] equals ["~/"] {
        Str:template = "'~/' expects an integer, found {}";
        $Type_Criteria:criteria = IntType_Criteria [];
        if !expect [a] satisfies [criteria] state: [state] template: [template]
            && expect [b] satisfies [criteria] state: [state] template: [template] {
            return null;
        };
        return [common type_ between [at] and [bt]]
            .expect["Numeric types_ should have a common type_"];
    } elif [spelling] equals ["**"] {
        if !expect numeric [a] and [b] op: [operator] state: [state]  {
            return null;
        };
        $Type_:t = RType_ [[at#$NumericType_?].unwrap.bits];
        given bt as UnsignedIntegerType_:uint_type_ {
            t = at;
        };
        return t;
    } elif ([spelling] equals ["="]) || ([spelling] equals ["+="])
        || ([spelling] equals ["-="]) || ([spelling] equals ["*="])
        || ([spelling] equals ["/="]) || ([spelling] equals ["%="]) {
        return NullType_ [];
    } else {
        abort ["Operator {} not implemented" % operator.spelling];
    };
}

$Expression?#[BiOperator:op] on [$Expression:a] and [$Expression:b] state: [ParseState:state] b_scope: [ExprScope:b_scope] {
    W:s = a.start_index;
    W:e = b.end_index;
    $Type_?:maybe_t = type_ for_ [op] on [a] and [b] state: [state];
    if !maybe_t {
        return null;
    };
    $Type_:t = [maybe_t].unwrap;
    Str:spelling = op.spelling;
    switch spelling
    ("&&") {return AndExpression [s, e, t, a, b, b_scope];}
    ("||") {return OrExpression [s, e, t, a, b, b_scope];}
    (">") {return GreaterExpression [s, e, t, a, b];}
    ("<") {return LessExpression [s, e, t, a, b];}
    (">=") {return GreaterEqualExpression [s, e, t, a, b];}
    ("<=") {return LessEqualExpression [s, e, t, a, b];}
    ("==") {return EqualExpression [s, e, t, a, b];}
    ("!=") {return NotEqualExpression [s, e, t, a, b];}
    ("+") {return PlusExpression [s, e, t, a, b];}
    ("-") {return MinusExpression [s, e, t, a, b];}
    ("*") {return MultiplyExpression [s, e, t, a, b];}
    ("/") {
        given [a].try_float_value as R:a_R {
            given [b].try_float_value as R:b_R {
                return FloatConstantExpression [s, e, t, a_R / b_R];
            };
        };
        return DivideExpression [s, e, t, a, b];
    }
    ("~/") {return IntDivideExpression [s, e, t, a, b];}
    ("%") {
        if [t] is equal to [Str_] {
            given a as FormatChainExpression:chain_expr {
                chain_expr.end_index = e;
                [chain_expr.substitutions].append[b];
                return chain_expr;
            } else {
                return FormatChainExpression [s, e, t, a, [$Expression] [b]];
            };
        } else {
            return ModuloExpression [s, e, t, a, b];
        };
    }
    ("**") {return ExponentiationExpression [s, e, t, a, b];}
    ("=") {return assign [b] to [a] state: [state];};
    if ([spelling] equals ["+="]) || ([spelling] equals ["-="])
        || ([spelling] equals ["*="]) || ([spelling] equals ["/="])
        || ([spelling] equals ["%="]) {
        return inplace op [op] on [a] and [b] state: [state] b_scope: [b_scope];
    };
    abort ["Operator {} not implemented" % op.spelling];
}

$Expression?#inplace op [BiOperator:op] on [$Expression:a] and [$Expression:b] state: [ParseState:state] b_scope: [ExprScope:b_scope] {
    // cut off the last char of the op ("+=" -> "+")
    Str:sub_op_name = [op.spelling].slice[0][[op.spelling].len - 1];
    BiOperator:sub_op = BiOperator [sub_op_name, op.cond_eval];
    given [sub_op] on [a] and [b] state: [state] b_scope: [b_scope]
    as $Expression:op_result {
        return assign [op_result] to [a] state: [state];
    } else {
        return null;
    };
}

$Expression?#parse expr [ParseState:state] ctx: [ExprContext:ctx] {
    $Expression?:maybe_first_term = parse expr term [state] ctx: [ctx];
    if !maybe_first_term {
        return null;
    };
    $Expression:first_term = [maybe_first_term].unwrap;
    if [state].is_at_end || [state].cur_id == ';' || [state].cur_id == ',' {
        return first_term;
    };

    L:level_count = [get bioperator levels].len;
    [$Expression?]:stack = [$Expression?]*level_count;
    [BiOperator?]:operator_stack = [BiOperator?]*level_count;
    [ExprContext?]:ctx_stack = [ExprContext?]*level_count;

    stack[level_count - 1] = first_term;
    ctx_stack[level_count - 1] = ctx;
    L:stack_i = level_count - 1;

    while true {
        BiOperatorLevel:level = get bioperator levels[stack_i];

        ExprContext:op_ctx = [ctx_stack[stack_i]].unwrap;

        BiOperator?:maybe_matching_operator = match [level] against [state];

        $Expression?:maybe_b = null;
        given maybe_matching_operator as BiOperator:operator {
            if operator.cond_eval {
                // the operator may sometimes not evaluate the second operand
                // (what we are parsing right now), so we need to parse it
                // in its own ExprContext so variables defined here aren't
                // avaliable externally
                op_ctx = [op_ctx].new_scope;
            };
            given parse expr term [state] ctx: [op_ctx] as $Expression:b {
                operator_stack[stack_i] = operator;
                maybe_b = b;
                stack_i = level_count - 1;
            } else {
                return null;
            };
        } else {
            $Expression:b = [stack[stack_i]].unwrap;
            if stack_i == 0 {
                return b;
            };
            maybe_b = b;
            stack[stack_i] = null;
            stack_i -= 1;
        };

        $Expression:b = [maybe_b].unwrap;
        given stack[stack_i] as $Expression:a {
            BiOperator:operator = [operator_stack[stack_i]].unwrap;
            given [operator] on [a] and [b] state: [state] b_scope: [op_ctx.scope]
            as $Expression:expr {
                stack[stack_i] = expr;
            } else {
                return null;
            };
        } else {
            stack[stack_i] = b;
        };
        ctx_stack[stack_i] = op_ctx;
    };
}

Block?#parse block inside [ParseState:state] ctx: [ExprContext:ctx] {
    W:start = [state].cur_start;
    ExprContext:block_ctx = [ctx].new_scope;
    [$Expression]:lines = [$Expression] [];
    $Type_?:maybe_type_ = null;
    while ![state].is_at_end {
        given parse expr [state] ctx: [block_ctx] as $Expression:expr {
            [lines].append[expr];
            maybe_type_ = expr.type_;
        } else {
            // error recovery
            while ![state].is_at_end && [state].cur_id != ';' {
                [state].consume;
            };
        };
        if [state].is_at_end {
            break;
        } elif [state].cur_id == ';' {
            [state].consume;
        } else {
            [state].error_at_current msg: ["Expected ';' to terminate statement"];
            while ![state].is_at_end && [state].last_id != ';' {
                [state].consume;
            };
        };
        maybe_type_ = null;
    };
    if !maybe_type_ {
        NullType_:type_ = NullType_ [];
        W:pos = [state].last_end + 1;
        [lines].append[NullExpression [pos, pos, type_]];
        maybe_type_ = type_;
    };
    return Block [start, [state].last_end, [maybe_type_].unwrap, lines, ctx.scope];
}

Block?#parse block [ParseState:state] ctx: [ExprContext:ctx] {
    if ![state].consume[T_CURLY_GROUP] {
        return null;
    };
    ParseState:inner_state = [state].last_substate;
    return parse block inside [inner_state] ctx: [ctx];
}
