%import parsing;
%import tokenizer;
%import structs;
%import epslfiles;
%import modules;

@extends Node;
Type_Node {
    $Type_:type_
}

@super;
Type_ {}

@extends Type_;
StructType_ {
    Struct_:struct_
}

@extends Type_;
AnyStructType_ {}

@extends Type_;
NullType_ {}

@extends Type_;
NeverType_ {}

@extends Type_;
OptionalType_ {
    $Type_:sub
}

@extends Type_;
PolyType_ {
    Struct_:struct_
}

@extends Type_;
GenericType_ {
    Str:name,
    [$Type_]:generics
}

@super;
@extends Type_;
NumericType_ {
    W:bits
}

@super;
@extends NumericType_;
IntegerType_ {}

@super;
@extends IntegerType_;
UnsignedIntegerType_ {}

@extends UnsignedIntegerType_;
BoolType_ {}

@extends UnsignedIntegerType_;
ByteType_ {}

@extends UnsignedIntegerType_;
WType_ {}

@extends IntegerType_;
ZType_ {}

@extends NumericType_;
RType_ {}

@super;
Type_Criteria {}

@extends Type_Criteria;
AnyType_Criteria {}

@extends Type_Criteria;
SpecificType_Criteria {
    $Type_:type_
}

@extends Type_Criteria;
ConvertibleToType_Criteria {
    $Type_:type_
}

@extends Type_Criteria;
NumericType_Criteria {}

@extends Type_Criteria;
IntType_Criteria {}

@extends Type_Criteria;
UnsignedIntType_Criteria {}

@extends Type_Criteria;
GenericType_Criteria {
    Str:name,
    [$Type_Criteria]:generic_criteria
}

// note that while this struct is perfectly identical to GenericType_Criteria,
// they have different sematic purposes
GenericType_Description {
    Str:name,
    [$Type_Criteria]:generic_criteria
}

Type_Context {
    [Struct_]:structs,
    [GenericType_Description]:generic_types_
}

Field {
    Str:name,
    $Type_:type_
}

GenericType_#Array_ of [$Type_:sub] {
    return GenericType_ ["Array", [$Type_] [sub]];
}

GenericType_#Str_ {
    return Array_ of [ByteType_ [8]];
}

Type_Context#type_ context of [$S0ModuleContent:s0_modcon] {
    $S1ModuleContent:modcon = [s0_modcon#$S1ModuleContent?]
        .expect["Expected $S1ModuleContent"];
    return Type_Context [modcon.scoped_structs, [GenericType_Description] []];
}

Struct_?#get struct named [Str:name] from [Type_Context:ctx] {
    for Struct_:struct_ in ctx.structs {
        if [name] equals [struct_.name] {
            return struct_;
        };
    };
    return null;
}

Type_Node?#parse type_ node state: [ParseState:state] ctx: [Type_Context:ctx] {
    W:start = [state].cur_start;
    given parse type_ state: [state] ctx: [ctx] as $Type_:type_ {
        W:end = [state].last_end;
        return Type_Node [start, end, type_];
    } else {
        return null;
    };
}

$Type_?#parse type_ state: [ParseState:state] ctx: [Type_Context:ctx] {
    if ![state].require_more why: ["type"] {
        return null;
    };
    [state].consume;
    W:id = [state].last_id;
    if id == T_IDENT {
        Str:txt = [[state].last_data].read_identifier;
        given parse type_ from name [txt] state: [state] ctx: [ctx] as $Type_:type_ {
            return parse more type_ from: [type_] state: [state] ctx: [ctx];
        };
        return null;
    } elif id == T_SQUARE_GROUP {
        ParseState:substate = [state].last_substate;
        $Type_?:maybe_subtype_ = parse type_ state: [substate] ctx: [ctx];
        if !maybe_subtype_ {
            return null;
        };
        if ![substate].require_finished why: ["']' before {}"] {
            return null;
        };
        $Type_:type_ = Array_ of [[maybe_subtype_].unwrap];
        return parse more type_ from: [type_] state: [state] ctx: [ctx];
    } elif id == '$' {
        if ![state].consume[T_IDENT] name: ["struct name"] {
            return null;
        };
        Str:name = [[state].last_data].read_identifier;
        given get struct named [name] from [ctx] as Struct_:struct_ {
            if !struct_.is_super {
                [state].error_at_previous
                    msg: ["The struct '{}' is not a super type, and thus cannot be used polymorphically." % name];
            };
            $Type_:type_ = PolyType_ [struct_];
            return parse more type_ from: [type_] state: [state] ctx: [ctx];
        } else {
            [state].error_at_previous msg: ["No such struct '{}'" % name];
            return null;
        };
    } else {
        [state].unconsume;
        [state].error_about_current msg: ["Expected type"];
        return null;
    };
}

[W]#valid R_ bit counts {
    return [W] [16, 32, 64, 128];
}

$Type_?#parse type_ from name [Str:name] state: [ParseState:state] ctx: [Type_Context:ctx] {
    switch name
    ("Struct") {
        return AnyStructType_ [];
    }
    ("Null") {
        return NullType_ [];
    }
    ("Never") {
        return NeverType_ [];
    }
    ("Bool") {
        return BoolType_ [1];
    }
    ("Byte") {
        return ByteType_ [8];
    };
    [Str]:bit_names = [Str] ["W", "Z", "R"];
    for Str:bit_name in bit_names {
        if ![name].starts_with[bit_name] {
            continue;
        };
        W?:maybe_bits = null;
        if [name].len > [bit_name].len {
            Str:after = [name].slice_from[[bit_name].len];
            Z?:maybe_val = parse_int[after];
            if !maybe_val {
                continue;
            };
            Z:val = [maybe_val].unwrap;
            if val <= 0 {
                [state].error_at_previous
                    msg: ["The bit count must be postive"];
            } else {
                maybe_bits = val#W;
            };
        };
        switch bit_name
        ("W") {
            return WType_ [[maybe_bits] || [32]];
        }
        ("Z") {
            return ZType_ [[maybe_bits] || [32]];
        }
        ("R") {
            W:bits = [maybe_bits] || [64];
            if ![valid R_ bit counts].index_of[bits] {
                [state].error_at_previous
                    msg: ["R cannot have {} bits" % bits];
                bits = 64;
            };
            return RType_ [bits];
        }
        {abort;};
    };
    given get struct named [name] from [ctx] as Struct_:struct_ {
        if struct_.is_abstract {
            [state].error_at_previous
                msg: ["The struct '{}' is abstract, and thus must be used polymorphically.
Perhaps you meant '${}'?" % name % name];
        };
        return StructType_ [struct_];
    };
    GenericType_Description?:maybe_generic_type_ = null;
    for GenericType_Description:canidate_type_ in ctx.generic_types_ {
        if [name] equals [canidate_type_.name] {
            maybe_generic_type_ = canidate_type_;
            break;
        };
    };
    if !maybe_generic_type_ {
        [state].error_at_previous msg: ["Invalid type name '{}'" % name];
        return null;
    };
    GenericType_Description:generic_type_ = [maybe_generic_type_].unwrap;
    L:expected_generic_count = [generic_type_.generic_criteria].len;
    if expected_generic_count == 0 {
        return GenericType_ [name, [$Type_] []];
    };
    L:start_index = state.index;
    if ![state].consume['<'] {
        return null;
    };
    [Type_Node]:generic_nodes = [Type_Node] [];
    while true {
        Type_Node?:maybe_generic = parse type_ node state: [state] ctx: [ctx];
        given maybe_generic as Type_Node:generic_node {
            [generic_nodes].append[generic_node];
        } else {
            return null;
        };
        if ![state].require_more why: ["Expected '>'"] {
            return null;
        };
        [state].consume;
        W:id = [state].last_id;
        if id == '>' {
            break;
        } elif id == ',' {

        } else {
            [state].error_about_current msg: ["Expected ',' or '>'"];
            return null;
        };
    };
    if [generic_nodes].len != expected_generic_count {
        Str:msg = "Expected {} generics, got {} generics"
            % expected_generic_count % [generic_nodes].len;
        [state].error_at[[L] [start_index, state.index]] msg: [msg];
        return null;
    };
    [$Type_]:generics = [$Type_] [];
    for L:i to expected_generic_count {
        $Type_Criteria:criteria = generic_type_.generic_criteria[i];
        Type_Node:generic_node = generic_nodes[i];
        if ![generic_node.type_].satisfies[criteria] {
            [state].error_at[generic_node]
                msg: ["Expected {}" % [criteria].englisch];
            return null;
        };
        [generics].append[generic_node.type_];
    };
    return GenericType_ [name, generics];
}

$Type_#parse more type_ from: [$Type_:type_] state: [ParseState:state] ctx: [Type_Context:ctx] {
    if [state].is_at_end {
        return type_;
    } elif [state].cur_id == '?' {
        [state].consume;
        return parse more type_ from: [OptionalType_ [type_]]
            state: [state] ctx: [ctx];
    } else {
        return type_;
    };
}

Field?#parse field state: [ParseState:state] ctx: [Type_Context:ctx] {
    if ![state].consume[T_IDENT] name: ["field name"] {
        return null;
    };
    Str:name = [[state].last_data].read_identifier;
    if ![state].consume[':'] {
        return null;
    };
    given parse type_ state: [state] ctx: [ctx] as $Type_:type_ {
        return Field [name, type_];
    };
    return null;
}

Bool#[$Type_:type_].is_numeric {
    return !!(type_#$NumericType_?);
}

Bool#[$Type_:type_].is_int {
    return !!(type_#$IntegerType_?);
}

Bool#[$Type_:type_].is_unsigned_int {
    return !!(type_#$UnsignedIntegerType_?);
}

Struct_?#struct_ of [$Type_:type_] {
    given type_ as PolyType_:poly_type_ {
        return poly_type_.struct_;
    } given type_ as StructType_:struct_type_ {
        return struct_type_.struct_;
    };
    return null;
}

Bool#types_ [$Type_:a] and [$Type_:b] are compatible {
    return !!common type_ between [a] and [b];
}

$Type_?#common type_ between [$Type_:a] and [$Type_:b] {
    given a as $NumericType_:a {
        given b as $NumericType_:b {
            return common type_ between [a] and [b];
        };
    };

    if [b] is convertible to [a] {
        return a;
    } elif [a] is convertible to [b] {
        return b;
    };

    given a as NullType_:null_a {
        // we know b isn't Optional because of the convertible checks
        return OptionalType_ [b];
    };
    given b as NullType_:null_b {
        // we know a isn't Optional because of the convertible checks
        return OptionalType_ [a];
    };

    given struct_ of [a] as Struct_:struct_a {
        given struct_ of [b] as Struct_:struct_b {
            given common struct_ between [struct_a] and [struct_b]
            as Struct_:common_struct {
                return PolyType_ [common_struct];
            } else {
                return null;
            };
        };
    };

    if !!(a#OptionalType_?) || !!(b#OptionalType_?) {
        given a as OptionalType_:optional_a {
            a = optional_a.sub;
        };
        given b as OptionalType_:optional_b {
            b = optional_b.sub;
        };
        given common type_ between [a] and [b] as $Type_:common_sub {
            return OptionalType_ [common_sub];
        };
    };

    return null;
}

$NumericType_#common type_ between [$NumericType_:a] and [$NumericType_:b] {
    W:bits = a.bits;
    if b.bits > bits {
        bits = b.bits;
    };

    if !!(a#RType_?) || !!(b#RType_?) {
        [W]:valid_bit_counts = valid R_ bit counts;
        W:chosen_bit_count = [valid_bit_counts].at[-1];
        for W:bit_count in valid_bit_counts {
            if bit_count >= bits {
                chosen_bit_count = bit_count;
                break;
            };
        };
        return RType_ [chosen_bit_count];
    };

    given a as ZType_:a_Z {
        return ZType_ [bits];
    };
    given b as ZType_:b_Z {
        return ZType_ [bits];
    };

    return WType_ [bits];
}

Struct_?#common struct_ between [Struct_:a] and [Struct_:b] {
    [Struct_]:a_extendees = [a].extendee_list;
    [Struct_]:b_extendees = [b].extendee_list;
    L:min_len = [a_extendees].len;
    if [b_extendees].len < min_len {
        min_len = [b_extendees].len;
    };
    Struct_?:greatest_common = null;
    for L:i from 1 to min_len+1 {
        if [a_extendees].at[-i] == [b_extendees].at[-i] {
            greatest_common = [a_extendees].at[-i];
        } else {
            break;
        };
    };
    return greatest_common;
}

Bool#[$Type_:a] is convertible to [$Type_:b] {
    if [a] is equal to [b] {
        return true;
    };
    Bool:b_was_optional = false;
    while true {
        given b as OptionalType_:optional_b {
            b = optional_b.sub;
            b_was_optional = true;
        } else {
            break;
        };
        given a as OptionalType_:optional_a {
            a = optional_a.sub;
        };
    };
    given a as NeverType_:never_a {
        return true;
    };
    given a as NullType_:null_a {
        if b_was_optional {
            return true;
        };
    };
    given struct_ of [a] as Struct_:a_struct {
        if [a_struct] is convertible to [b] {
            return true;
        };
    };
    given a as $NumericType_:numeric_a {
        given b as $NumericType_:numeric_b {
            if [numeric_a] is convertible to [numeric_b] {
                return true;
            };
        };
    };
    return false;
}

Bool#[$NumericType_:a] is convertible to [$NumericType_:b] {
    given b as RType_:b_R {
        return true;
    };
    if a.bits > b.bits {
        return false;
    };
    given a as $UnsignedIntegerType_:a_uint {
        return true;
    };
    given a as ZType_:a_Z {
        given b as ZType_:b_Z {
            return true;
        };
    };
    return false;
}

Bool#can [Struct_:struct_] be an AnyStruct {
    // if struct_.is_value is true, struct_.has_rc must be false
    return struct_.has_rc;
}

Bool#[Struct_:a_struct] is convertible to [$Type_:b_type_] {
    given b_type_ as AnyStructType_:b_any_struct {
        return can [a_struct] be an AnyStruct;
    } given b_type_ as PolyType_:poly_b {
        Struct_:b_struct = poly_b.struct_;
        return a_struct == b_struct || [a_struct] extends [b_struct];
    };
    return false;
}

Bool#[$Type_:a] is castable to [$Type_:b] {
    if [a] is equal to [b] {
        return true;
    };
    Bool:b_was_optional = false;
    while true {
        given b as OptionalType_:optional_b {
            b = optional_b.sub;
            b_was_optional = true;
        } else {
            break;
        };
        given a as OptionalType_:optional_a {
            a = optional_a.sub;
        };
    };
    given a as NeverType_:never_a {
        return true;
    };
    given a as NullType_:null_a {
        if b_was_optional {
            return true;
        };
    };
    given struct_ of [a] as Struct_:a_struct {
        if [a_struct] is convertible to [b] {
            return true;
        };
    };
    given struct_ of [b] as Struct_:b_struct {
        if b_was_optional && [a] is castable to optional [b_struct] {
            return true;
        };
    };
    given a as $NumericType_:numeric_a {
        given b as $NumericType_:numeric_b {
            return true;
        };
    };
    return false;
}

Bool#[$Type_:a_type_] is castable to optional [Struct_:b_struct] {
    given a_type_ as PolyType_:poly_a {
        Struct_:a_struct = poly_a.struct_;
        return [b_struct] extends [a_struct];
    } given a_type_ as AnyStructType_:any_struct_a {
        return can [b_struct] be an AnyStruct;
    };
    return false;
}

Bool#types_ [[$Type_]:options] encompass [$Type_:super] {
    given struct_ of [super] as Struct_:super_struct {
        given super_struct.sealed_extenders as [Struct_]:extenders {
            for Struct_:extender in extenders {
                Bool:found = false;
                for $Type_:option in options {
                    given struct_ of [option] as Struct_:option_struct {
                        if option_struct == extender {
                            found = true;
                            break;
                        };
                    };
                };
                if !found {
                    return false;
                };
            };
            return true;
        };
    };
    return false;
}

Bool#[$Type_:a] is equal to [$Type_:b] {
    given a as StructType_:struct_a {
        given b as StructType_:struct_b {
            return struct_a.struct_ == struct_b.struct_;
        };
        return false;
    } given a as AnyStructType_:any_struct_a {
        return !!(b#AnyStructType_?);
    } given a as NullType_:null_a {
        return !!(b#NullType_?);
    } given a as NeverType_:never_a {
        return !!(b#NeverType_?);
    } given a as OptionalType_:optional_a {
        given b as OptionalType_:optional_b {
            return [optional_a.sub] is equal to [optional_b.sub];
        };
        return false;
    } given a as PolyType_:poly_a {
        given b as PolyType_:poly_b {
            return poly_a.struct_ == poly_b.struct_;
        };
        return false;
    } given a as GenericType_:generic_a {
        given b as GenericType_:generic_b {
            if [generic_a.name] not equals [generic_b.name] {
                return false;
            };
            return [generic_a.generics] equals [generic_b.generics];
        };
        return false;
    } given a as BoolType_:bool_a {
        return !!(b#BoolType_?);
    } given a as ByteType_:byte_a {
        return !!(b#ByteType_?);
    } given a as WType_:W_a {
        given b as WType_:W_b {
            return W_a.bits == W_b.bits;
        };
        return false;
    } given a as ZType_:Z_a {
        given b as ZType_:Z_b {
            return Z_a.bits == Z_b.bits;
        };
        return false;
    } given a as RType_:R_a {
        given b as RType_:R_b {
            return R_a.bits == R_b.bits;
        };
        return false;
    } else {
        abort ["Invalid Type_"];
    };
}

Bool#[[$Type_]:a] equals [[$Type_]:b] {
    if [a].len != [b].len {
        return false;
    };
    for L:i enumerating a {
        if ![a[i]] is equal to [b[i]] {
            return false;
        };
    };
    return true;
}

Bool#[$Type_:a] is greater than [$Type_:b] {
    return [b] is convertible to [a] && ![a] is convertible to [b];
}

Bool#[$Type_:type_].satisfies[$Type_Criteria:criteria] {
    given criteria as AnyType_Criteria:any_criteria {
        return true;
    } given criteria as SpecificType_Criteria:specific_criteria {
        return [type_] is equal to [specific_criteria.type_];
    } given criteria as ConvertibleToType_Criteria:convertible_criteria {
        return [type_] is convertible to [convertible_criteria.type_];
    } given criteria as NumericType_Criteria:numeric_criteria {
        return [type_].is_numeric;
    } given criteria as IntType_Criteria:int_criteria {
        return [type_].is_int;
    } given criteria as UnsignedIntType_Criteria:unsigned_criteria {
        return [type_].is_unsigned_int;
    } given criteria as GenericType_Criteria:generic_criteria {
        given type_ as GenericType_:generic_type_ {
            if [generic_type_.name] not equals [generic_criteria.name] {
                return false;
            };
            if [generic_type_.generics].len != [generic_criteria.generic_criteria].len {
                abort ["Generic type_ and generic type_ criteria generic count do not match"];
            };
            for L:i enumerating generic_type_.generics {
                $Type_Criteria:criterion = generic_criteria.generic_criteria[i];
                if ![generic_type_.generics[i]].satisfies[criterion] {
                    return false;
                };
            };
            return true;
        };
        return false;
    } else {
        abort ["Invalid Type_Criteria"];
    };
}

Str#[$Type_:type_].stringify {
    given type_ as StructType_:struct_type_ {
        return struct_type_.struct_.name;
    } given type_ as AnyStructType_:any_struct_type_ {
        return "Struct";
    } given type_ as NullType_:null_type_ {
        return "Null";
    } given type_ as NeverType_:never_type_ {
        return "Never";
    } given type_ as OptionalType_:optional_type_ {
        return "{}?" % [optional_type_.sub].stringify;
    } given type_ as PolyType_:poly_type_ {
        return "${}" % poly_type_.struct_.name;
    } given type_ as GenericType_:generic_type_ {
        if [generic_type_.generics].len == 0 {
            return generic_type_.name;
        };
        Str:generics_txt = Str [];
        for $Type_:type_ in generic_type_.generics {
            if generics_txt {
                [generics_txt].extend[", "];
            };
            [generics_txt].extend[[type_].stringify];
        };
        return "{}<{}>" % generic_type_.name % generics_txt;
    } given type_ as BoolType_:bool_type_ {
        return "Bool";
    } given type_ as ByteType_:byte_type_ {
        return "Byte";
    } given type_ as WType_:W_type_ {
        return "W{}" % W_type_.bits;
    } given type_ as ZType_:Z_type_ {
        return "Z{}" % Z_type_.bits;
    } given type_ as RType_:R_type_ {
        return "R{}" % R_type_.bits;
    } else {
        abort ["Invalid Type_"];
    };
}

Str#[$Type_Criteria:criteria].englisch {
    given criteria as AnyType_Criteria:any_criteria {
        return "any type";
    } given criteria as SpecificType_Criteria:specific_criteria {
        return "the type {}" % [specific_criteria.type_].stringify;
    } given criteria as ConvertibleToType_Criteria:convertible_criteria {
        return "a type convertible to {}" % [convertible_criteria.type_].stringify;
    } given criteria as NumericType_Criteria:numeric_criteria {
        return "a numeric type";
    } given criteria as IntType_Criteria:int_criteria {
        return "an integer type";
    } given criteria as UnsignedIntType_Criteria:unsigned_criteria {
        return "an unsigned integer type";
    } given criteria as GenericType_Criteria:generic_criteria {
        L:generic_count = [generic_criteria.generic_criteria].len;
        if generic_count == 0 {
            return "a {}" % generic_criteria.name;
        };
        Str:t_str = Str [];
        Str:criteria_str = Str [];
        for L:i enumerating generic_criteria.generic_criteria {
            $Type_Criteria:criterion = generic_criteria.generic_criteria[i];
            if i {
                [t_str].extend[", "];
                if i == generic_count - 1 {
                    [criteria_str].extend[", and "];
                } else {
                    [criteria_str].extend[", "];
                };
            };
            Str:generic_name = "T";
            if generic_count > 1 {
                generic_name = "T{}" % (i + 1);
            };
            [t_str].extend[generic_name];
            [criteria_str].extend["{} is {}" % generic_name % [criterion].englisch];
        };
        return "a {}<{}> (where {})" % generic_criteria.name % t_str % criteria_str;
    } else {
        abort ["Invalid Type_Criteria"];
    };
}
