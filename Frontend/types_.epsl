%import parsing;
%import tokenizer;
%import structs;
%import epslfiles;
%import modules;

@extends Node;
Type_Node {
    $Type_:type_
}

@super;
Type_ {}

@extends Type_;
StructType_ {
    Struct_:struct_
}

@extends Type_;
NullType_ {}

@extends Type_;
NeverType_ {}

@extends Type_;
OptionalType_ {
    $Type_:sub
}

@extends Type_;
PolyType_ {
    Struct_:struct_
}

@extends Type_;
GenericType_ {
    Str:name,
    [$Type_]:generics
}

@super;
@extends Type_;
NumericType_ {
    W:bits
}

@super;
@extends NumericType_;
IntegerType_ {}

@super;
@extends IntegerType_;
UnsignedIntegerType_ {}

@extends UnsignedIntegerType_;
BoolType_ {}

@extends UnsignedIntegerType_;
ByteType_ {}

@extends UnsignedIntegerType_;
WType_ {}

@extends IntegerType_;
ZType_ {}

@extends NumericType_;
RType_ {}

@super;
Type_Criteria {}

@extends Type_Criteria;
AnyType_Criteria {}

@extends Type_Criteria;
SpecificType_Criteria {
    $Type_:type_
}

@extends Type_Criteria;
ConvertibleToType_Criteria {
    $Type_:type_
}

// TODO: add type criteria for:
// * number
// * int
// * unsigned int

@extends Type_Criteria;
GenericType_Criteria {
    Str:name,
    [$Type_Criteria]:generic_criteria
}

// note that while this struct is perfectly identical to GenericType_Criteria,
// they have different sematic purposes
GenericType_Description {
    Str:name,
    [$Type_Criteria]:generic_criteria
}

Type_Context {
    [Struct_]:structs,
    [GenericType_Description]:generic_types_
}

Field {
    Str:name,
    $Type_:type_
}

Type_Context#type_ context of [$S0ModuleContent:s0_modcon] {
    $S1ModuleContent:modcon = [($S1ModuleContent?)s0_modcon]
        .expect["Expected $S1ModuleContent"];
    return Type_Context [modcon.scoped_structs, [GenericType_Description] []];
}

Struct_?#get struct named [Str:name] from [Type_Context:ctx] {
    for Struct_:struct_ in ctx.structs {
        if [name] equals [struct_.name] {
            return struct_;
        };
    };
    return null;
}

Type_Node?#parse type_ node state: [ParseState:state] ctx: [Type_Context:ctx] {
    W:start = [state].cur_start;
    given parse type_ state: [state] ctx: [ctx] as $Type_:type_ {
        W:end = [state].last_end;
        return Type_Node [start, end, type_];
    } else {
        return null;
    };
}

$Type_?#parse type_ state: [ParseState:state] ctx: [Type_Context:ctx] {
    if ![state].require_more why: ["type"] {
        return null;
    };
    [state].consume;
    W:id = [state].last_id;
    if id == T_IDENT {
        Str:txt = [[state].last_data].read_identifier;
        given parse type_ from name [txt] state: [state] ctx: [ctx] as $Type_:type_ {
            return parse more type_ from: [type_] state: [state] ctx: [ctx];
        };
        return null;
    } elif id == T_SQUARE_GROUP {
        ParseState:substate = [state].last_substate;
        $Type_?:maybe_subtype_ = parse type_ state: [substate] ctx: [ctx];
        if !maybe_subtype_ {
            return null;
        };
        if ![substate].require_finished why: ["']' before {}"] {
            return null;
        };
        $Type_:type_ = GenericType_ ["Array", [$Type_] [[maybe_subtype_].unwrap]];
        return parse more type_ from: [type_] state: [state] ctx: [ctx];
    } elif id == '$' {
        if ![state].consume[T_IDENT] name: ["struct name"] {
            return null;
        };
        Str:name = [[state].last_data].read_identifier;
        given get struct named [name] from [ctx] as Struct_:struct_ {
            if !struct_.is_super {
                [state].error_at_previous
                    msg: ["The struct '{}' is not a super type, and thus cannot be used polymorphically." % name];
            };
            $Type_:type_ = PolyType_ [struct_];
            return parse more type_ from: [type_] state: [state] ctx: [ctx];
        } else {
            [state].error_at_previous msg: ["No such struct '{}'" % name];
            return null;
        };
    } else {
        [state].unconsume;
        [state].error_about_current msg: ["Expected type"];
        return null;
    };
}

$Type_?#parse type_ from name [Str:name] state: [ParseState:state] ctx: [Type_Context:ctx] {
    switch name
    ("Null") {
        return NullType_ [];
    }
    ("Never") {
        return NeverType_ [];
    }
    ("Bool") {
        return BoolType_ [1];
    }
    ("Byte") {
        return ByteType_ [8];
    };
    [Str]:bit_names = [Str] ["W", "Z", "R"];
    for Str:bit_name in bit_names {
        if ![name].starts_with[bit_name] {
            continue;
        };
        W?:bits = null;
        if [name].len > [bit_name].len {
            Str:after = [name].slice_from[[bit_name].len];
            Z?:maybe_val = parse_int[after];
            if !maybe_val {
                continue;
            };
            Z:val = [maybe_val].unwrap;
            if val < 0 {
                [state].error_at_previous
                    msg: ["The bit count cannot be negative"];
                return null;
            };
            bits = (W)val;
        };
        switch bit_name
        ("W") {
            return WType_ [[bits] || [32]];
        }
        ("Z") {
            return ZType_ [[bits] || [32]];
        }
        ("R") {
            return RType_ [[bits] || [64]];
        }
        {abort;};
    };
    given get struct named [name] from [ctx] as Struct_:struct_ {
        if struct_.is_abstract {
            [state].error_at_previous
                msg: ["The struct '{}' is abstract, and thus must be used polymorphically.
Perhaps you meant '${}'?" % name % name];
        };
        return StructType_ [struct_];
    };
    GenericType_Description?:maybe_generic_type_ = null;
    for GenericType_Description:canidate_type_ in ctx.generic_types_ {
        if [name] equals [canidate_type_.name] {
            maybe_generic_type_ = canidate_type_;
            break;
        };
    };
    if !maybe_generic_type_ {
        [state].error_at_previous msg: ["Invalid type name '{}'" % name];
        return null;
    };
    GenericType_Description:generic_type_ = [maybe_generic_type_].unwrap;
    L:expected_generic_count = [generic_type_.generic_criteria].len;
    if expected_generic_count == 0 {
        return GenericType_ [name, [$Type_] []];
    };
    L:start_index = state.index;
    if ![state].consume['<'] {
        return null;
    };
    [Type_Node]:generic_nodes = [Type_Node] [];
    while true {
        Type_Node?:maybe_generic = parse type_ node state: [state] ctx: [ctx];
        given maybe_generic as Type_Node:generic_node {
            [generic_nodes].append[generic_node];
        } else {
            return null;
        };
        if ![state].require_more why: ["Expected '>'"] {
            return null;
        };
        [state].consume;
        W:id = [state].last_id;
        if id == '>' {
            break;
        } elif id == ',' {

        } else {
            [state].error_about_current msg: ["Expected ',' or '>'"];
            return null;
        };
    };
    if [generic_nodes].len != expected_generic_count {
        Str:msg = "Expected {} generics, got {} generics"
            % expected_generic_count % [generic_nodes].len;
        [state].error_at[[L] [start_index, state.index]] msg: [msg];
        return null;
    };
    [$Type_]:generics = [$Type_] [];
    for L:i to expected_generic_count {
        $Type_Criteria:criteria = generic_type_.generic_criteria[i];
        Type_Node:generic_node = generic_nodes[i];
        if ![generic_node.type_].satisfies[criteria] {
            [state].error_at[generic_node]
                msg: ["Expected {}" % [criteria].englisch];
            return null;
        };
        [generics].append[generic_node.type_];
    };
    return GenericType_ [name, generics];
}

$Type_#parse more type_ from: [$Type_:type_] state: [ParseState:state] ctx: [Type_Context:ctx] {
    if [state].is_at_end {
        return type_;
    } elif [state].cur_id == '?' {
        [state].consume;
        return parse more type_ from: [OptionalType_ [type_]]
            state: [state] ctx: [ctx];
    } else {
        return type_;
    };
}

Field?#parse field state: [ParseState:state] ctx: [Type_Context:ctx] {
    if ![state].consume[T_IDENT] name: ["field name"] {
        return null;
    };
    Str:name = [[state].last_data].read_identifier;
    if ![state].consume[':'] {
        return null;
    };
    given parse type_ state: [state] ctx: [ctx] as $Type_:type_ {
        return Field [name, type_];
    };
    return null;
}

Struct_?#struct_ of [$Type_:type_] {
    given type_ as PolyType_:poly_type_ {
        return poly_type_.struct_;
    } given type_ as StructType_:struct_type_ {
        return struct_type_.struct_;
    };
    return null;
}

Bool#types_ [$Type_:a] and [$Type_:b] are compatible {
    abort ["not implemented"];
}

$Type_?#common type_ between [$Type_:a] and [$Type_:b] {
    abort ["not implemented"];
}

Bool#[$Type_:a] is convertible to [$Type_:b] {
    if [a] is equal to [b] {
        return true;
    };
    Bool:b_is_optional = false;
    while true {
        given b as OptionalType_:optional_b {
            b = optional_b.sub;
            b_is_optional = true;
        } else {
            break;
        };
        given a as OptionalType_:optional_a {
            a = optional_a.sub;
        };
    };
    given a as NeverType_:never_a {
        return true;
    }
    given a as NullType_:null_a {
        if b_is_optional {
            return true;
        };
    };
    given b as PolyType_:poly_b {
        given struct_ of [a] as Struct_:a_struct {
            if [a_struct] is convertible to [poly_b] {
                return true;
            };
        };
    }
    given a as $NumericType_:numeric_a {
        given b as $NumericType_:numeric_b {
            if [numeric_a] is convertible to [numeric_b] {
                return true;
            };
        };
    };
    return false;
}

Bool#[$NumericType_:a] is convertible to [$NumericType_:b] {
    given b as RType_:b_R {
        return true;
    };
    if a.bits > b.bits {
        return false;
    };
    given a as $UnsignedIntegerType_:a_uint {
        return true;
    };
    given a as ZType_:a_Z {
        given b as ZType_:b_Z {
            return true;
        };
    };
    return false;
}

Bool#[Struct_:a] is convertible to [PolyType_:b_type_] {
    Struct_:b = b_type_.struct_;
    return a == b || [a] extends [b];
}

Bool#[$Type_:a] is castable to [$Type_:b] {
    abort ["not implemented"];
}

Bool#[$Type_:a] is equal to [$Type_:b] {
    given a as StructType_:struct_a {
        given b as StructType_:struct_b {
            return struct_a.struct_ == struct_b.struct_;
        };
        return false;
    } given a as NullType_:null_a {
        return !!(NullType_?)b;
    } given a as NeverType_:never_a {
        return !!(NeverType_?)b;
    } given a as OptionalType_:optional_a {
        given b as OptionalType_:optional_b {
            return [optional_a.sub] is equal to [optional_b.sub];
        };
        return false;
    } given a as PolyType_:poly_a {
        given b as PolyType_:poly_b {
            return poly_a.struct_ == poly_b.struct_;
        };
        return false;
    } given a as GenericType_:generic_a {
        given b as GenericType_:generic_b {
            if [generic_a.name] not equals [generic_b.name] {
                return false;
            };
            return [generic_a.generics] equals [generic_b.generics];
        };
        return false;
    } given a as BoolType_:bool_a {
        return !!(BoolType_?)b;
    } given a as ByteType_:byte_a {
        return !!(ByteType_?)b;
    } given a as WType_:W_a {
        given b as WType_:W_b {
            return W_a.bits == W_b.bits;
        };
        return false;
    } given a as ZType_:Z_a {
        given b as ZType_:Z_b {
            return Z_a.bits == Z_b.bits;
        };
        return false;
    } given a as RType_:R_a {
        given b as RType_:R_b {
            return R_a.bits == R_b.bits;
        };
        return false;
    } else {
        abort ["Invalid Type_"];
    };
}

Bool#[[$Type_]:a] equals [[$Type_]:b] {
    if [a].len != [b].len {
        return false;
    };
    for L:i enumerating a {
        if ![a[i]] is equal to [b[i]] {
            return false;
        };
    };
    return true;
}

Bool#[$Type_:a] is greater than [$Type_:b] {
    return [b] is convertible to [a] && ![a] is convertible to [b];
}

Bool#[$Type_:type_].satisfies[$Type_Criteria:criteria] {
    given criteria as AnyType_Criteria:any_criteria {
        return true;
    } given criteria as SpecificType_Criteria:specific_criteria {
        return [type_] is equal to [specific_criteria.type_];
    } given criteria as ConvertibleToType_Criteria:convertible_criteria {
        return [type_] is convertible to [convertible_criteria.type_];
    } given criteria as GenericType_Criteria:generic_criteria {
        given type_ as GenericType_:generic_type_ {
            if [generic_type_.name] not equals [generic_criteria.name] {
                return false;
            };
            if [generic_type_.generics].len != [generic_criteria.generic_criteria].len {
                abort ["Generic type_ and generic type_ criteria generic count do not match"];
            };
            for L:i enumerating generic_type_.generics {
                $Type_Criteria:criterion = generic_criteria.generic_criteria[i];
                if ![generic_type_.generics[i]].satisfies[criterion] {
                    return false;
                };
            };
            return true;
        };
        return false;
    } else {
        abort ["Invalid Type_Criteria"];
    };
}

Str#[$Type_:type_].stringify {
    given type_ as StructType_:struct_type_ {
        return struct_type_.struct_.name;
    } given type_ as NullType_:null_type_ {
        return "Null";
    } given type_ as NeverType_:never_type_ {
        return "Never";
    } given type_ as OptionalType_:optional_type_ {
        return "{}?" % [optional_type_.sub].stringify;
    } given type_ as PolyType_:poly_type_ {
        return "${}" % poly_type_.struct_.name;
    } given type_ as GenericType_:generic_type_ {
        if [generic_type_.generics].len == 0 {
            return generic_type_.name;
        };
        Str:generics_txt = Str [];
        for $Type_:type_ in generic_type_.generics {
            if generics_txt {
                [generics_txt].extend[", "];
            };
            [generics_txt].extend[[type_].stringify];
        };
        return "{}<{}>" % generic_type_.name % generics_txt;
    } given type_ as BoolType_:bool_type_ {
        return "Bool";
    } given type_ as ByteType_:byte_type_ {
        return "Byte";
    } given type_ as WType_:W_type_ {
        return "W{}" % W_type_.bits;
    } given type_ as ZType_:Z_type_ {
        return "Z{}" % Z_type_.bits;
    } given type_ as RType_:R_type_ {
        return "R{}" % R_type_.bits;
    } else {
        abort ["Invalid Type_"];
    };
}

Str#[$Type_Criteria:criteria].englisch {
    given criteria as AnyType_Criteria:any_criteria {
        return "any type";
    } given criteria as SpecificType_Criteria:specific_criteria {
        return "the type {}" % [specific_criteria.type_].stringify;
    } given criteria as ConvertibleToType_Criteria:convertible_criteria {
        return "a type convertible to {}" % [convertible_criteria.type_].stringify;
    } given criteria as GenericType_Criteria:generic_criteria {
        L:generic_count = [generic_criteria.generic_criteria].len;
        if generic_count == 0 {
            return "a {}" % generic_criteria.name;
        };
        Str:t_str = Str [];
        Str:criteria_str = Str [];
        for L:i enumerating generic_criteria.generic_criteria {
            $Type_Criteria:criterion = generic_criteria.generic_criteria[i];
            if i {
                [t_str].extend[", "];
                if i == generic_count - 1 {
                    [criteria_str].extend[", and "];
                } else {
                    [criteria_str].extend[", "];
                };
            };
            Str:generic_name = "T";
            if generic_count > 1 {
                generic_name = "T{}" % (i + 1);
            };
            [t_str].extend[generic_name];
            [criteria_str].extend["{} is {}" % generic_name % [criterion].englisch];
        };
        return "a {}<{}> (where {})" % generic_criteria.name % t_str % criteria_str;
    } else {
        abort ["Invalid Type_Criteria"];
    };
}
