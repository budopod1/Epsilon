%import epslctx;
%import epslfiles;
%import types_;

@super;
@extends Node;
Expression {
    $Type_:type_
}

@super;
@extends Expression;
ConstantExpression {}

@extends ConstantExpression;
BoolConstantExpression {
    Bool:val
}

@extends ConstantExpression;
IntConstantExpression {
    Z64:val
}

@extends ConstantExpression;
FloatConstantExpression {
    R:val
}

@extends ConstantExpression;
ByteConstantExpression {
    Byte:val
}

@extends ConstantExpression;
StrConstantExpression {
    Str:val
}

@extends Expression;
NullExpression {}

@extends Expression;
VariableDeclarationExpression {
    ScopeVar:var,
    $Expression:initializer
}

@extends Expression;
VariableExpression {
    ScopeVar:var
}

@extends Expression;
NegateExpression {
    $Expression:o
}

@extends Expression;
NotExpression {
    $Expression:o
}

@extends Expression;
ParenExpression {
    $Expression:inner
}

@extends Expression;
CastExpression {
    $Expression:castee
}

@extends Expression;
VariableAssignmentExpression {
    ScopeVar:recipient,
    $Expression:value
}

@super;
@extends Expression;
BiOperationExpression {
    $Expression:a,
    $Expression:b
}

@super;
@extends BiOperationExpression;
BiLogicalExpression {
    ExprScope:b_scope
}

@extends BiLogicalExpression;
AndExpression {}

@extends BiLogicalExpression;
OrExpression {}

@extends BiOperationExpression;
GreaterExpression {}

@extends BiOperationExpression;
LessExpression {}

@extends BiOperationExpression;
GreaterEqualExpression {}

@extends BiOperationExpression;
LessEqualExpression {}

@extends BiOperationExpression;
EqualExpression {}

@extends BiOperationExpression;
NotEqualExpression {}

@extends BiOperationExpression;
PlusExpression {}

@extends BiOperationExpression;
MinusExpression {}

@extends BiOperationExpression;
MultiplyExpression {}

@extends BiOperationExpression;
DivideExpression {}

@extends BiOperationExpression;
IntDivideExpression {}

@extends BiOperationExpression;
ModuloExpression {}

@extends BiOperationExpression;
ExponentiationExpression {}

@extends Expression;
ReturnExpression {
    $Expression:returnee
}

@extends Expression;
BreakExpression {
    $Expression:result
}

@extends Expression;
ContinueExpression {}

@extends Expression;
Block {
    [$Expression]:lines,
    ExprScope:scope
}

@extends Expression;
WhileExpression {
    $Expression:cond,
    ExprScope:cond_scope,
    Block:block,
    Block?:else_,
}

@extends Expression;
IfExpression {
    [IfBranch]:branches,
    Block?:else_
}

IfBranch {
    $Expression:cond,
    ExprScope:cond_scope,
    Block:block
}

@extends Expression;
GivenExpression {
    $Expression:scrutinee,
    [GivenArm]:arms,
    Block?:else_,
    Bool:else_never
}

GivenArm {
    ScopeVar:var,
    Block:block
}

@extends Expression;
ForExpression {
    ScopeVar:var,
    ToForClause?:to_clause,
    FromForClause?:from_clause,
    StepForClause?:step_clause,
    InForClause?:in_clause,
    EnumeratingForClause?:enumerating_clause,
    WhereForClause?:where_clause,
    MapForClause?:map_clause,
    InplaceForClause?:inplace_clause,
    Block:block,
    Block?:else_
}

@extends Node;
ToForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
FromForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
StepForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
InForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
EnumeratingForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
WhereForClause {
    $Expression:val,
    ExprScope:scope
}

@extends Node;
MapForClause {}

@extends Node;
InplaceForClause {}

// a temporary node representing a variable declaration
// that is part of a larger expression
@extends Node;
SubVarDeclNode {
    ScopeVar:var
}

Bool#[$Expression:expr].is_truthy_const {
    given expr as BoolConstantExpression:bool_const {
        return bool_const.val;
    } given expr as IntConstantExpression:int_const {
        return int_const.val != 0;
    } given expr as FloatConstantExpression:float_const {
        return float_const.val != 0;
    } given expr as ByteConstantExpression:byte_const {
        return byte_const.val != '\0';
    } given expr as StrConstantExpression:str_const {
        return [str_const.val].len > 0;
    } else {
        return false;
    };
}

Z64?#[$Expression:expr].try_int_value {
    given expr as BoolConstantExpression:bool_const {
        return bool_const.val;
    } given expr as IntConstantExpression:int_const {
        return int_const.val;
    } given expr as ByteConstantExpression:byte_const {
        return byte_const.val;
    } else {
        return null;
    };
}

R?#[$Expression:expr].try_float_value {
    given expr as BoolConstantExpression:bool_const {
        return bool_const.val;
    } given expr as IntConstantExpression:int_const {
        return int_const.val;
    } given expr as FloatConstantExpression:float_const {
        return float_const.val;
    } given expr as ByteConstantExpression:byte_const {
        return byte_const.val;
    } else {
        return null;
    };
}
