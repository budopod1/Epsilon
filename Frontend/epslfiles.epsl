%import tokenizer;
%import toplevel;
%import grouper;
%import modules;
%import parsing;
%import structs;
%import iotools;
%import types_;
%import errors;
%import paths;

@super;
NodeWSpan {
    W:start_index,
    W:end_index
}

@super;
@extends NodeWSpan;
ToplevelItem {}

@super;
@extends NodeWSpan;
Annotation {}

@extends Annotation;
PrivateAnnotation {}

@extends Annotation;
IDAnnotation {
    Str:id
}

@extends Annotation;
ValueAnnotation {}

@extends Annotation;
SuperAnnotation {}

@extends Annotation;
ConcreteAnnotation {}

@extends Annotation;
SealedAnnotation {}

@extends Annotation;
ExtendsAnnotation {
    Str:extendee
}

@extends ToplevelItem;
ImportDeclaration {
    Import:import
}

@super;
@extends ToplevelItem;
AnnotatableNode {
    [$Annotation]:annotations
}

@extends AnnotatableNode;
RawGlobal {
    Tokens:tokens
}

@extends AnnotatableNode;
RawFunction {
    Tokens:ret_type_,
    Tokens:template,
    Tokens:body
}

@extends NodeWSpan;
S1EPSLFunction {
    Bool:is_public,
    FunctionDeclaration:func_decl,
    Tokens:body
}

@extends AnnotatableNode;
RawStruct {
    Str:name,
    Tokens:body
}

@extends S0ModuleContent;
S0EPSLModuleContent {
    Str:file_text,
    [RawGlobal]:raw_globals,
    [RawFunction]:raw_functions,
    [RawStruct]:raw_structs
}

@extends NodeWSpan;
S1EPSLStruct {
    Bool:is_public,
    Struct_:struct_,
    Tokens:body
}

@extends S1ModuleContent;
S1EPSLModuleContent {
    Str:file_text,
    [S1EPSLStruct]:s1_structs,
    [RawGlobal]:raw_globals,
    [RawFunction]:raw_functions
}

@extends NodeWSpan;
EPSLStruct {
    Struct_:struct
}

@extends S2ModuleContent;
S2EPSLModuleContent {
    Str:file_text,
    [S1EPSLFunction]:s1_functions
}

Str#[RawGlobal:raw_global].stringify {
    return "RawGlobal({})" % [raw_global.tokens].stringify;
}

Str#[RawFunction:raw_function].stringify {
    return "RawFunction({}#{}, {})"
        % [raw_function.ret_type_].stringify
        % [raw_function.template].stringify
        % [raw_function.body].stringify;
}

Str#[RawStruct:raw_struct].stringify {
    return "RawStruct({}, {})"
        % raw_struct.name
        % [raw_struct.body].stringify;
}

Str#[S0EPSLModuleContent:modcon].stringify {
    Str:globals_str = Str [];
    for (RawGlobal:raw_global in modcon.raw_globals) {
        if (globals_str) {
            [globals_str].extend[", "];
        };
        [globals_str].extend[[raw_global].stringify];
    };

    Str:functions_str = Str [];
    for (RawFunction:raw_function in modcon.raw_functions) {
        if (functions_str) {
            [functions_str].extend[", "];
        };
        [functions_str].extend[[raw_function].stringify];
    };

    Str:structs_str = Str [];
    for (RawStruct:raw_struct in modcon.raw_structs) {
        if (structs_str) {
            [structs_str].extend[", "];
        };
        [structs_str].extend[[raw_struct].stringify];
    };

    return "S0EPSLModuleContent(
imports: {}
raw_globals: {}
raw_functions: {}
raw_structs: {}
)" % [modcon.imports].stringify % globals_str % functions_str % structs_str;
}

S0ModconResult#load epsl file [Path:path] {
    FileReadResult:file_result = read file [path];
    if [file_result.errors].any {
        return S0ModconResult [null, file_result.errors];
    };
    given file_result.txt as Str:txt {
        TokenizationResult:tokens_result = tokenize [txt];
        if tokens_result.errors {
            return S0ModconResult [
                null, bundle [tokens_result] txt: [txt] path: [path]
            ];
        };
        TokenizationResult:group_result = group tokens [tokens_result.tokens];
        if group_result.errors {
            return S0ModconResult [
                null, bundle [group_result] txt: [txt] path: [path]
            ];
        };
        S0EPSLModuleContent:modcon = S0EPSLModuleContent [
            path, [Import] [], txt, [RawGlobal] [], [RawFunction] [], [RawStruct] []
        ];
        return parse_toplevel[group_result.tokens] onto: [modcon];
    } else {
        abort;
    };
}

S1ModconResult#cook epsl struct declarations [Module:module] {
    [ParseError]:errors = [ParseError] [];
    S0EPSLModuleContent:raw_modcon = [(S0EPSLModuleContent?)module.content]
        .expect["Expected S0EPSLModuleContent"];
    [Struct_]:public_structs = [Struct_] [];
    [Struct_]:all_structs = [Struct_] [];
    [S1EPSLStruct]:s1_structs = [S1EPSLStruct] [];
    for RawStruct:raw_struct in raw_modcon.raw_structs {
        Bool:is_public = true;
        Str:name = raw_struct.name;
        Bool:is_value = false;
        Bool:is_super = false;
        Bool:is_concrete = false;
        Bool:is_sealed = false;
        StructRef?:extendee = null;
        for $Annotation:annotation in raw_struct.annotations {
            given annotation as PrivateAnnotation:private_annotation {
                is_public = false;
            } given annotation as ValueAnnotation:value_annotation {
                is_value = true;
            } given annotation as SuperAnnotation:super_annotation {
                is_super = true;
            } given annotation as ConcreteAnnotation:concrete_annotation {
                is_concrete = true;
            } given annotation as SealedAnnotation:sealed_annotation {
                is_sealed = true;
            } given annotation as ExtendsAnnotation:extends_annotation {
                extendee = StructRef [extends_annotation.extendee, module, null];
            } else {
                [errors].append[ParseError [
                    "Structs cannot receive this type of annotation",
                    annotation.start_index, annotation.end_index
                ]];
                continue;
            };
        };
        if is_value && (is_super || extendee) {
            [errors].append[ParseError [
                "Structs cannot both be marked @value and be marked @super or @extends",
                raw_struct.start_index, raw_struct.end_index
            ]];
        };
        if is_concrete && !is_super {
            [errors].append[ParseError [
                "The @concrete annotation is superfluous, as the struct is not annotated with @super",
                raw_struct.start_index, raw_struct.end_index
            ]];
        };
        if is_sealed && !is_super {
            [errors].append[ParseError [
                "The @sealed annotation is superfluous, as the struct is not annotated with @super",
                raw_struct.start_index, raw_struct.end_index
            ]];
        };
        Bool:is_abstract = is_super && !is_concrete;
        Struct_:struct_decl = Struct_ [
            name, is_value, is_abstract, is_super, is_sealed, extendee, null
        ];
        if is_public {
            [public_structs].append[struct_decl];
        };
        [all_structs].append[struct_decl];
        [s1_structs].append[S1EPSLStruct [
            raw_struct.start_index, raw_struct.end_index,
            is_public, struct_decl, raw_struct.body
        ]];
    };
    $ErrorBundle:error_bundle = bundle [errors]
        txt: [raw_modcon.file_text] path: [raw_modcon.absolute_path];
    return S1ModconResult [S1EPSLModuleContent [
        raw_modcon.absolute_path, raw_modcon.imports, public_structs,
        all_structs, raw_modcon.file_text, s1_structs, raw_modcon.raw_globals,
        raw_modcon.raw_functions
    ], error_bundle];
}

Global?#parse global from [RawGlobal:raw_global] errors: [[ParseError]:errors] ctx: [Type_Context:ctx] {
    ParseState:state = ParseState [raw_global.tokens, 0, errors];
    given parse field state: [state] ctx: [ctx] as Field:field {
        if ![state].require_finished why: ["';'"] {
            return null;
        };
        return Global [field];
    };
    return null;
}

#parse struct [S1EPSLStruct:epsl_struct] errors: [[ParseError]:errors] ctx: [Type_Context:ctx] {
    ParseState:state = ParseState [epsl_struct.body, 0, errors];
    [Field]:fields = [Field] [];
    epsl_struct.struct_.fields = fields;
    while ![state].is_at_end {
        given parse field state: [state] ctx: [ctx] as Field:field {
            [fields].append[field];
        } else {
            return;
        };
        if [state].is_at_end {
            return;
        };
        if ![state].consume[','] name: ["',' after field"] {
            return;
        };
    };
}

Bool#parse function template [Tokens:tokens] to [[$TemplateSegment]:segments] args: [[Field]:args] errors: [[ParseError]:errors] ctx: [Type_Context:ctx] {
    ParseState:state = ParseState [tokens, 0, errors];
    while ![state].is_at_end {
        W:id = [state].cur_id;
        [state].consume;
        if id == T_IDENT {
            Str:name = [[state].last_data].read_identifier;
            [segments].append[IdentifierTemplateSegment [name]];
        } elif id == T_SQUARE_GROUP {
            ParseState:arg_state = [state].last_substate;
            given parse field state: [arg_state] ctx: [ctx] as Field:field {
                [args].append[field];
            } else {
                return false;
            };
            if ![arg_state].is_at_end {
                [arg_state].error_about_current msg: ["Expected ']'"];
                return false;
            };
            [segments].append[ArgumentTemplateSegment []];
        } elif id < 32 || id >= 127 {
            [state].error_about_current msg: ["Invalid syntax"];
            return false;
        } else {
            [segments].append[SymbolTemplateSegment [(Byte)id]];
        };
    };
    return true;
}

Str#make symbol from segments [[$TemplateSegment]:segments] {
    Str:result = Str [];
    for $TemplateSegment:segment in segments {
        if result {
            [result].append['_'];
        };
        given segment as IdentifierTemplateSegment:identifier_segment {
            [result].extend[identifier_segment.text];
        } given segment as ArgumentTemplateSegment:argument_segment {
            [result].extend["[]"];
        } given segment as SymbolTemplateSegment:symbol_segment {
            [result].append[symbol_segment.symbol];
        } else {
            abort "Invalid TemplateSegment";
        };
    };
    return result;
}

S1EPSLFunction?#parse function [RawFunction:raw_function] errors: [[ParseError]:errors] ctx: [Type_Context:ctx] prefix: [Str:prefix] {
    ParseState:ret_state = ParseState [raw_function.ret_type_, 0, errors];
    $Type_?:maybe_ret_type_ = parse type_ state: [ret_state] ctx: [ctx];
    if !maybe_ret_type_ {
        return null;
    };
    $Type_:ret_type_ = [maybe_ret_type_].unwrap;

    [$TemplateSegment]:template = [$TemplateSegment] [];
    [Field]:arguments = [Field] [];
    if !parse function template [raw_function.template] to [template] args: [arguments] errors: [errors] ctx: [ctx] {
        return null;
    };

    Str?:callee = null;
    Bool:is_public = true;
    for $Annotation:annotation in raw_function.annotations {
        given annotation as PrivateAnnotation:private_annotation {
            is_public = false;
        } given annotation as IDAnnotation:id_annotation {
            callee = id_annotation.id;
        } else {
            [errors].append[ParseError [
                "Functions cannot receive this type of annotation",
                annotation.start_index, annotation.end_index
            ]];
        };
    };
    if !callee {
        callee = "{}:{}" % prefix % make symbol from segments [template];
    };

    FunctionDeclaration:func_decl = FunctionDeclaration [
        template, arguments, FUNC_SOURCE_LOCAL, ret_type_, [callee].unwrap,
        true, // takes ownership
        true // result (may be) in params
    ];

    return S1EPSLFunction [
        raw_function.start_index, raw_function.end_index,
        is_public, func_decl, raw_function.body
    ];
}

S2ModconResult#cook exports [Module:module] {
    [ParseError]:errors = [ParseError] [];
    S1EPSLModuleContent:s1_modcon = [(S1EPSLModuleContent?)module.content]
        .expect["Expected S1EPSLModuleContent"];
    Type_Context:ctx = type_ context of [s1_modcon];
    [Global]:globals = [Global] [];
    for RawGlobal:raw_global in s1_modcon.raw_globals {
        given parse global from [raw_global] errors: [errors] ctx: [ctx]
        as Global:global {
            [globals].append[global];
        };
    };
    for S1EPSLStruct:s1_struct in s1_modcon.s1_structs {
        parse struct [s1_struct] errors: [errors] ctx: [ctx];
    };
    [S1EPSLFunction]:s1_functions = [S1EPSLFunction] [];
    [FunctionDeclaration]:func_decls = [FunctionDeclaration] [];
    for L:i enumerating s1_modcon.raw_functions {
        Str:prefix = "{}:{}" % s1_modcon.absolute_path % i;
        RawFunction:raw_function = s1_modcon.raw_functions[i];
        given parse function [raw_function] errors: [errors] ctx: [ctx] prefix: [prefix]
        as S1EPSLFunction:s1_function {
            [s1_functions].append[s1_function];
            [func_decls].append[s1_function.func_decl];
        };
    };
    $ErrorBundle:error_bundle = bundle [errors]
        txt: [s1_modcon.file_text] path: [s1_modcon.absolute_path];
    return S2ModconResult [S2EPSLModuleContent [
        s1_modcon.absolute_path, s1_modcon.imports, s1_modcon.structs,
        s1_modcon.scoped_structs, globals, func_decls, s1_modcon.file_text,
        s1_functions
    ], error_bundle];
}
