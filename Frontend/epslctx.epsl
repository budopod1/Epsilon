%import functions;
%import epslfiles;
%import types_;
%import exprs;

ScopeVar {
    W:i,
    Str:name,
    $Type_:type_
}

ScopeChain {
    ScopeVar?:var,
    ScopeChain?:next
}

ScopeSection {
    ScopeChain:start,
    ScopeChain:terminator
}

ScopeVar?#lookup variable [Str:name] in [ScopeChain:chain] {
    given chain.var as ScopeVar:var {
        if [var.name] equals [name] {
            return var;
        };
    };
    given chain.next as ScopeChain:next {
        return lookup variable [name] in [next];
    };
    return null;
}

ScopeVar#add var [Str:name] type_: [$Type_:type_] to: [ExprContext:ctx] {
    [ScopeVar]:vars = ctx.mod_ctx.vars;
    ScopeVar:var = ScopeVar [[vars].len#W, name, type_];
    [vars].append[var];
    ctx.scope.chain = ScopeChain [var, ctx.scope.chain];
    return var;
}

ExprScope#[ExprScope:scope].subscope {
    return ExprScope [scope.chain, scope.func_chain_end, scope.chain];
}

ExprContext#[ExprContext:ctx].new_scope {
    return ExprContext [
        ctx.mod_ctx, ctx.func_decl, [ctx.scope].subscope, ctx.loop_ctx
    ];
}

[ScopeVar]#[ScopeSection:section].list_vars {
    [ScopeVar]:vars = [ScopeVar] [];
    ScopeChain:here = section.start;
    while here != section.terminator {
        given here.var as ScopeVar:var {
            [vars].append[var];
        };
        given here.next as ScopeChain:next {
            here = next;
        } else {
            break;
        };
    };
    return vars;
}

ModuleContext {
    Type_Context:type__ctx,
    AvailableFuncs:avaliable_funcs,
    ScopeChain:global_chain,
    [ScopeVar]:vars
}

ExprScope {
    ScopeChain:chain,
    ScopeChain:func_chain_end,
    ScopeChain:scope_chain_end
}

ExprContext {
    ModuleContext:mod_ctx,
    FunctionDeclaration:func_decl,
    ExprScope:scope,
    LoopCtx?:loop_ctx
}

LoopCtx {
    [BreakExpression]:breaks,
    [ContinueExpression]:continues,
    ExprScope:scope
}
