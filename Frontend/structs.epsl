%import types_;
%import modules;
%import builder;
%import errors;

@super;
@concrete;
StructDeclaration {
    Str:name,
    Bool:is_value,
    Bool:is_abstract,
    Bool:is_super,
    Bool:is_sealed,
    StructRef?:extendee
}

@extends StructDeclaration;
Struct_ {
    [Field]:fields
}

Field {
    Type_:type_,
    Str:name
}

StructRef {
    Str:name,
    Module:src_mod,
    Struct_?:struct_
}

[FileError]#load struct_ extendees [Build:build] {
    [FileError]:errors = [FileError] [];
    for Module:module in build.modules {
        $S2ModuleContent:modcon = [($S2ModuleContent?)module.content]
            .expect["Expected $S2ModuleContent"];
        [Struct_]:local_structs = [modcon.scoped_structs].clone;
        load foreign structs for_ [module] build: [build];
        for Struct_:struct in modcon.structs {
            given load struct_ extendee [struct]
                local_structs: [local_structs] as FileError:error {
                [errors].append[error];
            };
        };
    };
    return errors;
}

#load foreign structs for_ [Module:module] build: [Build:build] {
    $S2ModuleContent:modcon = [($S2ModuleContent?)module.content]
        .expect["Expected $S2ModuleContent"];
    for Import:import in modcon.imports {
        Module:other_module = [build].lookup_module[import];
        $S2ModuleContent:other_modcon = [($S2ModuleContent?)other_module.content]
            .expect["Expected $S2ModuleContent"];
        [modcon.scoped_structs].extend[other_modcon.structs];
    };
}

FileError?#load struct_ extendee [Struct_:this_struct] local_structs: [[Struct_]:local_structs] {
    if !this_struct.extendee {
        return null;
    };
    StructRef:ref = [this_struct.extendee].unwrap;
    Module:this_module = ref.src_mod;
    if [this_struct.name] equals [ref.name] {
        return FileError [
            "The struct {} cannot extend itself" % ref.name,
            this_module.content.absolute_path
        ];
    };
    $S2ModuleContent:modcon = [($S2ModuleContent?)this_module.content]
        .expect["Expected $S2ModuleContent"];
    for Struct_:other_struct in modcon.scoped_structs {
        if [other_struct.name] not equals [ref.name] {
            continue;
        };
        if !other_struct.is_super {
            return FileError [
                "Struct {} cannot extend non super struct {}"
                    % this_struct.name % other_struct.name,
                this_module.content.absolute_path
            ];
        };
        if other_struct.is_sealed && ![local_structs].index_of[other_struct] {
            return FileError [
                "Struct {} cannot extend sealed struct {} located in a different module"
                    % this_struct.name % other_struct.name,
                this_module.content.absolute_path
            ];
        };
        ref.struct_ = other_struct;
        return null;
    };
    return FileError [
        "Cannot find struct {} that {} extends" % ref.name % this_struct.name,
        this_module.content.absolute_path
    ];
}

[FileError]#verify no recursive extendees [Build:build] {
    for Module:module in build.modules {
        $S2ModuleContent:modcon = [($S2ModuleContent?)module.content]
            .expect["Expected $S2ModuleContent"];
        for Struct_:struct in modcon.structs {
            FileError?:maybe_error = verify no recursive extendees [struct]
                seen: [[Struct_] []];
            given maybe_error as FileError:error {
                return [FileError] [error];
            };
        };
    };
    return [FileError] [];
}

FileError?#verify no recursive extendees [Struct_:struct] seen: [[Struct_]:seen] {
    if !struct.extendee {
        return null;
    };
    StructRef:ref = [struct.extendee].unwrap;
    if [seen].index_of[struct] {
        return FileError [
            "Struct {} is not allowed to (directly or indirectly) extend itself" % struct.name,
            ref.src_mod.content.absolute_path
        ];
    };
    [seen].append[struct];
    Struct_:extendee = [ref.struct_]
        .expect["Structs should have their extendees loaded"];
    return verify no recursive extendees [extendee] seen: [seen];
}
