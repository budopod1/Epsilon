%import epslfiles;
%import modules;
%import parsing;
%import builder;
%import errors;
%import types_;

Struct_ {
    Str:name,
    Bool:has_rc,
    Bool:is_readonly,
    Bool:is_value,
    Bool:is_abstract,
    Bool:is_super,
    Bool:is_sealed,
    StructRef?:extendee,
    // stores all extenders of a struct IFF the struct is sealed
    [Struct_]?:sealed_extenders,
    [Field]?:fields
}

StructRef {
    Str:name,
    Module:src_mod,
    Struct_?:struct_
}

Struct_?#[Struct_:struct_].extendee {
    given struct_.extendee as StructRef:ref {
        return [ref.struct_].expect["Unexpected uncooked struct"];
    };
    return null;
}

[Struct_]#[Struct_:struct_].extendee_list {
    [Struct_]:structs = [Struct_] [];
    while true {
        given [struct_].extendee as Struct_:extendee {
            [structs].append[extendee];
            struct_ = extendee;
        } else {
            return structs;
        };
    };
}

Bool#[Struct_:a] extends [Struct_:b] {
    while true {
        given [a].extendee as Struct_:a_extendee {
            a = a_extendee;
        } else {
            return false;
        };
        if a == b {
            return true;
        };
    };
}

#create sealed extender lists [Build:build] {
    for Module:module in build.modules {
        $S1ModuleContent:modcon = [module.content#$S1ModuleContent?]
            .expect["Expected $S1ModuleContent"];
        for Struct_:struct in modcon.structs {
            if struct.is_sealed {
                struct.sealed_extenders = [Struct_] [];
            };
        };
    };
}

[FileError]#load struct_ extendees [Build:build] {
    [FileError]:errors = [FileError] [];
    for Module:module in build.modules {
        $S1ModuleContent:modcon = [module.content#$S1ModuleContent?]
            .expect["Expected $S1ModuleContent"];
        [Struct_]:local_structs = [modcon.scoped_structs].clone;
        load foreign structs for_ [module] build: [build];
        for Struct_:struct in modcon.structs {
            given load struct_ extendee [struct]
                local_structs: [local_structs] as FileError:error {
                [errors].append[error];
            };
        };
    };
    return errors;
}

#load foreign structs for_ [Module:module] build: [Build:build] {
    $S1ModuleContent:modcon = [module.content#$S1ModuleContent?]
        .expect["Expected $S1ModuleContent"];
    for Import:import in modcon.imports {
        Module:other_module = [build].lookup_module[import];
        $S1ModuleContent:other_modcon = [other_module.content#$S1ModuleContent?]
            .expect["Expected $S1ModuleContent"];
        [modcon.scoped_structs].extend[other_modcon.structs];
    };
}

FileError?#load struct_ extendee [Struct_:this_struct] local_structs: [[Struct_]:local_structs] {
    if !this_struct.extendee {
        return null;
    };
    StructRef:ref = [this_struct.extendee].unwrap;
    Module:this_module = ref.src_mod;
    if [this_struct.name] equals [ref.name] {
        return FileError [
            "The struct {} cannot extend itself" % ref.name,
            this_module.content.absolute_path
        ];
    };
    $S1ModuleContent:modcon = [this_module.content#$S1ModuleContent?]
        .expect["Expected $S1ModuleContent"];
    for Struct_:other_struct in modcon.scoped_structs {
        if ![other_struct.name] equals [ref.name] {
            continue;
        };
        if !other_struct.is_super {
            return FileError [
                "Struct {} cannot extend non super struct {}"
                    % this_struct.name % other_struct.name,
                this_module.content.absolute_path
            ];
        };
        if this_struct.has_rc != other_struct.has_rc {
            Str:this_phrase = "does not have";
            if this_struct.has_rc {
                this_phrase = "has";
            };
            Str:other_phrase = "does not have";
            if other_struct.has_rc {
                other_phrase = "has";
            };
            return FileError [
                "Struct {}, which {} a reference counter cannot extend struct {}, which {} one"
                    % this_struct.name % this_phrase % other_struct.name % other_phrase,
                this_module.content.absolute_path
            ];
        };
        if other_struct.is_sealed && ![local_structs].index_of[other_struct] {
            return FileError [
                "Struct {} cannot extend sealed struct {} located in a different module"
                    % this_struct.name % other_struct.name,
                this_module.content.absolute_path
            ];
        };
        ref.struct_ = other_struct;
        given other_struct.sealed_extenders as [Struct_]:extenders {
            [extenders].append[this_struct];
        };
        return null;
    };
    return FileError [
        "Cannot find struct {} that {} extends" % ref.name % this_struct.name,
        this_module.content.absolute_path
    ];
}

[FileError]#verify no recursive extendees [Build:build] {
    for Module:module in build.modules {
        $S1ModuleContent:modcon = [module.content#$S1ModuleContent?]
            .expect["Expected $S1ModuleContent"];
        for Struct_:struct in modcon.structs {
            FileError?:maybe_error = verify no recursive extendees [struct]
                seen: [[Struct_] []];
            given maybe_error as FileError:error {
                return [FileError] [error];
            };
        };
    };
    return [FileError] [];
}

FileError?#verify no recursive extendees [Struct_:struct] seen: [[Struct_]:seen] {
    if !struct.extendee {
        return null;
    };
    StructRef:ref = [struct.extendee].unwrap;
    if [seen].index_of[struct] {
        return FileError [
            "Struct {} is not allowed to (directly or indirectly) extend itself" % struct.name,
            ref.src_mod.content.absolute_path
        ];
    };
    [seen].append[struct];
    Struct_:extendee = [ref.struct_]
        .expect["Structs should have their extendees loaded"];
    return verify no recursive extendees [extendee] seen: [seen];
}

#parse struct [S1EPSLStruct:epsl_struct] errors: [[ParseError]:errors] ctx: [Type_Context:ctx] {
    ParseState:state = ParseState [epsl_struct.body, 0, errors];
    [Field]:fields = [Field] [];
    epsl_struct.struct_.fields = fields;
    while ![state].is_at_end {
        given parse field state: [state] ctx: [ctx] as Field:field {
            [fields].append[field];
        } else {
            return;
        };
        if [state].is_at_end {
            return;
        };
        if ![state].consume[','] name: ["',' after field"] {
            return;
        };
    };
}

[Field]#[Struct_:struct].all_fields {
    [Field]:all_fields = [Field] [];
    for Struct_:extendee in [struct].extendee_list step -1 {
        [all_fields].extend[[extendee.fields].unwrap];
    };
    [all_fields].extend[[struct.fields].unwrap];
    return all_fields;
}
