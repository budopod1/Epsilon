%import tokenizer;
%import grouper;
%import modules;
%import parsing;
%import iotools;
%import epslfiles;
%import errors;
%import paths;

S0ModconResult#parse_toplevel[Tokens:tokens] onto: [S0EPSLModuleContent:modcon] {
    [$Annotation]:annotations = [$Annotation] [];
    ParseState:state = ParseState [tokens, 0, [ParseError] []];
    while ![state].is_at_end {
        W:id = [state].cur_id;
        $ToplevelItem?:item = null;
        if id == '@' {
            given parse_annotation[state] as $Annotation:annotation {
                [annotations].append[annotation];
            };
            continue;
        } elif id == '%' {
            item = parse_toplevel_percent_item[state];
        } else {
            item = parse_struct_or_func[state];
        };
        given item as $ToplevelItem:new_item {
            [modcon].add_item[new_item][annotations] state: [state];
            annotations = [$Annotation] [];
        };
    };
    $ErrorBundle:bundle = bundle [state.errors] txt: [modcon.file_text]
        path: [modcon.absolute_path];
    return S0ModconResult [modcon, bundle];
}

#[S0EPSLModuleContent:modcon].add_item[$ToplevelItem:item][[$Annotation]:annotations] state: [ParseState:state] {
    given item as ImportDeclaration:import_declaration {
        if (annotations) {
            [state].error_at[item] msg: ["Imports cannot receive annotations"];
        };
        [modcon.imports].append[import_declaration.import];
    } given item as RawGlobal:raw_global {
        raw_global.annotations = annotations;
        [modcon.raw_globals].append[raw_global];
    } given item as RawFunction:raw_function {
        raw_function.annotations = annotations;
        [modcon.raw_functions].append[raw_function];
    } given item as RawStruct:raw_struct {
        raw_struct.annotations = annotations;
        [modcon.raw_structs].append[raw_struct];
    } else {
        abort;
    };
}

$Annotation?#parse_annotation[ParseState:state] {
    W:start_index = [state].cur_start;
    [state].consume; // consume the @
    Bool:valid = [state].consume[T_IDENT] name: ["annotation name"];
    if valid {
        Str:annotation_type = [[state].last_data].read_identifier;
        switch annotation_type
        ("private") {
            if [state].consume[';'] name: ["';', as private annotation take no arguments"] {
                return PrivateAnnotation [start_index, [state].last_end];
            };
        }
        ("id") {
            if [state].consume[T_IDENT] name: ["id"] {
                Str:id = [[state].last_data].read_identifier;
                if [state].consume[';'] {
                    return IDAnnotation [start_index, [state].last_end, id];
                };
            };
        }
        ("value") {
            if [state].consume[';'] name: ["';', as value annotation take no arguments"] {
                return ValueAnnotation [start_index, [state].last_end];
            };
        }
        ("super") {
            if [state].consume[';'] name: ["';', as super annotation take no arguments"] {
                return SuperAnnotation [start_index, [state].last_end];
            };
        }
        ("concrete") {
            if [state].consume[';'] name: ["';', as concrete annotation take no arguments"] {
                return ConcreteAnnotation [start_index, [state].last_end];
            };
        }
        ("extends") {
            if [state].consume[T_IDENT] name: ["extendee name"] {
                Str:extendee_name = [[state].last_data].read_identifier;
                if [state].consume[';'] {
                    return ExtendsAnnotation [start_index, [state].last_end, extendee_name];
                };
            };
        }
        {
            [state].error_at_previous
                msg: ["Invalid annotation type '{}'" % annotation_type];
        };
    };
    [state].move_past_semicolon why: ["to terminate annotation"];
    return null;
}

$ToplevelItem?#parse_toplevel_percent_item[ParseState:state] {
    W:start_index = [state].cur_start;
    [state].consume; // consume the %
    Bool:valid = [state].consume[T_IDENT] name: ["'import' or 'global'"];
    if valid {
        Str:item_name = [[state].last_data].read_identifier;
        switch item_name
        ("import") {
            return parse_import[state] start: [start_index];
        }
        ("global") {
            return parse_global[state] start: [start_index];
        }
        {
            [state].error_at_previous
                msg: ["Expected 'import' or 'global', got '{}'" % item_name];
        };
    };
    [state].move_past_semicolon why: ["to terminate toplevel item"];
    return null;
}

ImportDeclaration?#parse_import[ParseState:state] start: [W:start_index] {
    [Str]:parts = [Str] [];
    Bool:was_dot = true;
    while ![state].is_at_end {
        W:token_id = [state].cur_id;
        if token_id == ';' {
            [state].consume;
            W:end_index = [state].last_end;
            return ImportDeclaration [start_index, end_index, Import [parts, null]];
        } elif token_id == '.' {
            if was_dot {
                [parts].append[".."];
            };
            was_dot = true;
        } elif was_dot && token_id == T_IDENT {
            [parts].append[[[state].cur_data].read_identifier];
            was_dot = false;
        } elif was_dot && token_id == T_STR {
            [parts].append[[[state].cur_data].read_string];
            was_dot = false;
        } else {
            Str?:msg = null;
            if was_dot {
                msg = "Expected '.' or path segment in import declaration";
            } else {
                msg = "Expected '.' in import declaration";
            };
            [state].error_about_current msg: [[msg].unwrap];
            // this might move past more than it should, but the
            // only result would be producing less errors than it could
            [state].move_past_semicolon why: ["to terminate import declaration"];
            return null;
        };
        [state].consume; // move past the token
    };
    [state].error_at_end msg: ["Expected ';' to terminate import"];
    return null;
}

RawGlobal?#parse_global[ParseState:state] start: [W:start_index] {
    Tokens:global_content = [state].new_section;
    while ![state].is_at_end {
        if [state].cur_id == ';' {
            [state].consume;
            W:end_index = [state].last_end;
            return RawGlobal [
                start_index, end_index, [$Annotation] [], global_content
            ];
        };
        [state].move_token_to[global_content];
    };
    [state].error_at_end msg: ["Expected ';' to terminate global"];
    return null;
}

$ToplevelItem?#parse_struct_or_func[ParseState:state] {
    W:start_index = [state].cur_start;
    if [state].cur_id == T_IDENT {
        [state].consume;
        $TokenData?:ident_data = [state].last_data;
        if [state].is_at_end {
            [state].error_at_end msg: ["Expected braces"];
            return null;
        };
        if [state].cur_id == T_CURLY_GROUP {
            [state].consume;
            W:end_index = [state].last_end;
            Str:struct_name = [ident_data].read_identifier;
            Tokens:tokens = [[state].last_data].read_group;
            return RawStruct [
                start_index, end_index, [$Annotation] [], struct_name, tokens
            ];
        } else {
            [state].unconsume;
        };
    };

    Tokens:ret_type_ = [state].new_section;
    while true {
        if [state].is_at_end {
            [state].error_at_end msg: ["Expected braces"];
            return null;
        };
        W:id = [state].cur_id;
        if id == '#' {
            [state].consume;
            break;
        } elif id == ';' {
            [state].error_at_current
                msg: ["Unexpected ';' character in function return type"];
            [state].consume;
            return null;
        } elif id == T_CURLY_GROUP {
            [state].error_after[state.index-1]
                msg: ["Unexpected braces: this is not valid syntax for a struct, and functions signatures require a '#'"];
            [state].consume;
            return null;
        };
        [state].move_token_to[ret_type_];
    };

    Tokens:template = [state].new_section;
    Tokens?:body = null;
    while true {
        if [state].is_at_end {
            [state].error_at_end msg: ["Expected braces"];
            return null;
        };
        W:id = [state].cur_id;
        if id == '#' {
            [state].error_at_current
                msg: ["Unexpected second '#' character in function template"];
            // don't consume this hashtag. another function will be parsed starting here
            // so we can report any errors in the rest of the template
            return null;
        } elif id == ';' {
            [state].error_at_current
                msg: ["Unexpected ';' character in function template"];
            [state].consume;
            return null;
        } elif id == T_CURLY_GROUP {
            [state].consume;
            body = [[state].last_data].read_group;
            break;
        };
        [state].move_token_to[template];
    };

    W:end_index = [state].last_end;
    return RawFunction [
        start_index, end_index, [$Annotation] [], ret_type_, template, [body].unwrap
    ];
}
