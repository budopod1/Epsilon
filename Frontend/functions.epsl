%import exprparsing;
%import epslfiles;
%import parsing;
%import epslctx;
%import types_;
%import errors;
%import exprs;

@super;
TemplateSegment {}

@extends TemplateSegment;
IdentifierTemplateSegment {
    Str:text
}

@extends TemplateSegment;
ArgumentTemplateSegment {}

@extends TemplateSegment;
SymbolTemplateSegment {
    Byte:symbol
}

FunctionDeclaration {
    [$TemplateSegment]:template,
    [Field]:arguments,
    W:source,
    $Type_:ret_type_,
    Str:callee,
    Bool:takes_ownership,
    Bool:result_in_params
}

W#FUNC_SOURCE_BUILTIN {
    return 0;
}

W#FUNC_SOURCE_FOREIGN {
    return 1;
}

W#FUNC_SOURCE_LOCAL {
    return 2;
}

S3EPSLFunction?#parse function [S2EPSLFunction:func] ctx: [ModuleContext:mod_ctx] errors: [[ParseError]:errors] {
    ExprScope:toplevel_scope = ExprScope [
        mod_ctx.global_chain, mod_ctx.global_chain, mod_ctx.global_chain
    ];
    ExprContext:ctx = ExprContext [
        mod_ctx, func.decl, toplevel_scope, null
    ];

    for Field:arg in func.decl.arguments {
        add var [arg.name] type_: [arg.type_] to: [ctx];
    };

    ParseState:state = ParseState [func.body, 0, errors];
    given parse block inside [state] ctx: [ctx] as Block:block {
        if ![block.type_] is convertible to [func.decl.ret_type_] {
            Str:msg = "Block result type {} not convertible to function return type {}"
                % [block.type_].stringify % [func.decl.ret_type_].stringify;
            [state].error_at[[block.lines].at[-1]] msg: [msg];
        };
        return S3EPSLFunction [func.start_index, func.end_index,
            func.is_public, func.decl, block];
    } else {
        return null;
    };
}
