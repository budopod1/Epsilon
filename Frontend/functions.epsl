%import exprparsing;
%import epslfiles;
%import parsing;
%import epslctx;
%import types_;
%import errors;
%import exprs;

@super;
TemplateSegment {}

@extends TemplateSegment;
IdentifierTemplateSegment {
    Str:text
}

@extends TemplateSegment;
ArgumentTemplateSegment {}

@extends TemplateSegment;
SymbolTemplateSegment {
    Byte:symbol
}

FuncTemplate {
    [$TemplateSegment]:segments
}

FunctionDeclaration {
    FuncTemplate:template,
    [Field]:parameters,
    W:source,
    $Type_:ret_type_,
    Str:callee,
    Bool:takes_ownership,
    Bool:result_in_params
}

AvailableFuncs {
    [FunctionGroup]:groups
}

FunctionGroup {
    [FunctionDeclaration]:funcs,
    FuncTemplate:template
}

W#FUNC_SOURCE_BUILTIN {
    return 0;
}

W#FUNC_SOURCE_FOREIGN {
    return 1;
}

W#FUNC_SOURCE_LOCAL {
    return 2;
}

S3EPSLFunction?#parse function [S2EPSLFunction:func] ctx: [ModuleContext:mod_ctx] errors: [[ParseError]:errors] {
    ExprScope:toplevel_scope = ExprScope [
        mod_ctx.global_chain, mod_ctx.global_chain, mod_ctx.global_chain
    ];
    ExprContext:ctx = ExprContext [
        mod_ctx, func.decl, toplevel_scope, null
    ];

    for Field:arg in func.decl.parameters {
        add var [arg.name] type_: [arg.type_] to: [ctx];
    };

    ParseState:state = ParseState [func.body, 0, errors];
    given parse block inside [state] ctx: [ctx] as Block:block {
        if ![block.type_] is convertible to [func.decl.ret_type_] {
            Str:msg = "Block result type {} not convertible to function return type {}"
                % [block.type_].stringify % [func.decl.ret_type_].stringify;
            [state].error_at[[block.lines].at[-1]] msg: [msg];
        };
        return S3EPSLFunction [func.start_index, func.end_index,
            func.is_public, func.decl, block];
    } else {
        return null;
    };
}

Bool#[$TemplateSegment:a] equals [$TemplateSegment:b] {
    given a as IdentifierTemplateSegment:identifier_a {
        given b as IdentifierTemplateSegment:identifier_b {
            return [identifier_a.text] equals [identifier_b.text];
        };
    } given a as ArgumentTemplateSegment:argument_a {
        return !!(b#ArgumentTemplateSegment?);
    } given a as SymbolTemplateSegment:symbol_a {
        given b as SymbolTemplateSegment:symbol_b {
            return symbol_a.symbol == symbol_b.symbol;
        };
    };
    return false;
}

Bool#[FuncTemplate:a] equals [FuncTemplate:b] {
    [$TemplateSegment]:as = a.segments;
    [$TemplateSegment]:bs = b.segments;
    if [as].len != [bs].len {
        return false;
    };
    for L:i enumerating as {
        if ![as[i]] equals [bs[i]] {
            return false;
        };
    };
    return true;
}

Str#stringify funcs param type_ options [[FunctionDeclaration]:funcs] {
    Str:result = Str [];
    for FunctionDeclaration:func in funcs {
        Str:line = Str [];
        for Field:param in func.parameters {
            if line {
                [line].extend[", "];
            };
            [line].extend[[param.type_].stringify];
        };
        if result {
            [result].extend[" or\n"];
        };
        [result].extend[line];
    };
    return result;
}

#[AvailableFuncs:funcs].add[FunctionDeclaration:func_decl] {
    for FunctionGroup:group in funcs.groups {
        if [func_decl.template] equals [group.template] {
            [group.funcs].append[func_decl];
            return;
        };
    };
    FunctionGroup:new_group = FunctionGroup [
        [FunctionDeclaration] [func_decl],
        func_decl.template
    ];
    [funcs.groups].append[new_group];
}

#[AvailableFuncs:funcs].sort_groups {
    [L]:template_lens = [L] [];
    for FunctionGroup:group in funcs.groups {
        [template_lens].append[[group.template.segments].len];
    };
    [L]:idxs = [template_lens].argsort;
    [FunctionGroup]:sorted_groups = [FunctionGroup] [];
    for L:idx in idxs {
        [sorted_groups].append[funcs.groups[idx]];
    };
    funcs.groups = sorted_groups;
}
