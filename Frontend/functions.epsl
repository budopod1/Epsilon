%import epslfiles;
%import parsing;
%import types_;
%import errors;
%import exprs;

@super;
TemplateSegment {}

@extends TemplateSegment;
IdentifierTemplateSegment {
    Str:text
}

@extends TemplateSegment;
ArgumentTemplateSegment {}

@extends TemplateSegment;
SymbolTemplateSegment {
    Byte:symbol
}

FunctionDeclaration {
    [$TemplateSegment]:template,
    [Field]:arguments,
    W:source,
    $Type_:ret_type_,
    Str:callee,
    Bool:takes_ownership,
    Bool:result_in_params
}

W#FUNC_SOURCE_BUILTIN {
    return 0;
}

W#FUNC_SOURCE_FOREIGN {
    return 1;
}

W#FUNC_SOURCE_LOCAL {
    return 2;
}

S3EPSLFunction?#parse function [S2EPSLFunction:func] errors: [[ParseError]:errors] {
    ParseState:state = ParseState [func.body, 0, errors];
    given parse block [state] as Block:block {
        return S3EPSLFunction [func.start_index, func.end_index,
            func.is_public, func.decl, block];
    } else {
        return null;
    };
}
