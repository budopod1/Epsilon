#import operations;
#import stringify;
#import eewriter;
#import equality;


BuiltinResult {
    Val?:result,
    Bool:result_in_params,
    Bool:result_is_params
}

BuiltinResult#make builtin result <Val:result> {
    return BuiltinResult [result, false, false];
}

BuiltinResult#make builtin result <Val:result> in params {
    return BuiltinResult [result, true, false];
}

BuiltinResult#make builtin result <Val:result> is params {
    return BuiltinResult [result, true, true];
}

BuiltinResult#make empty builtin result {
    return BuiltinResult [null, false, false];
}

BuiltinResult#builtin length with <[Val]:args> {
    return make builtin result [load [[args[0]].length]];
}

BuiltinResult#builtin capacity with <[Val]:args> {
    return make builtin result [load [[args[0]].capacity]];
}

BuiltinResult#builtin append with <[Val]:args> {
    Val:arr = args[0];
    Type_:generic = arr.type_.generics[0];
    Val:appendee = cast [args[1]] to [generic];
    Val:len = load [[arr].length];
    extern fn [null] ["increment_length"] [[Type_] [Internal_, L_]]
        [[Val] [cast [arr] to [Internal_], make elem int [generic]]];
    [[load [[arr].content]].idx[len]] = [appendee];
    [appendee].incr_ref;
    return make empty builtin result;
}

BuiltinResult#builtin require capacity with <[Val]:args> {
    Val:arr = args[0];
    Val:required_cap = cast [args[1]] to [L_];
    extern fn [null] ["require_capacity"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], required_cap, sizeof elem [arr.type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin shrink mem with <[Val]:args> {
    Val:arr = args[0];
    extern fn [null] ["shrink_mem"] [[Type_] [Internal_, L_]]
        [[Val] [cast [arr] to [Internal_], sizeof elem [arr.type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin pop with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    verify idx [idx] in array [arr];
    Val:elem = load [[arr].idx[idx]];
    [elem].checkless_decr_ref;
    extern fn [null] ["remove_at"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], idx, sizeof [elem.type_]]];
    // result is not in params when builtin finishes
    return make builtin result [elem];
}

BuiltinResult#builtin insert with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    Type_:generic = arr.type_.generics[0];
    Val:elem = cast [args[2]] to [generic];
    extern fn [null] ["insert_space"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], idx, sizeof [generic]]];
    [elem].incr_ref;
    [[arr].idx[idx]] = [elem];
    return make empty builtin result;
}

BuiltinResult#builtin clone with <[Val]:args> {
    return make builtin result [[args[0]].clone];
}

BuiltinResult#builtin extend with <[Val]:args> {
    Val:arr1 = cast [args[0]] to [Internal_];
    Val:arr2 = cast [args[1]] to [Internal_];
    assert type_ equality [args[0]], [args[1]];
    extern fn [null] ["extend_array"] [[Type_] [Internal_, Internal_, L_]]
        [[Val] [arr1, arr2, make elem generic int [args[0].type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin concat with <[Val]:args> {
    assert type_ equality [args[0]], [args[1]];
    Val:elem = make elem generic int [args[0].type_];
    extern fn [Internal_] ["concat_arrays"] [[Type_] [Internal_, Internal_, L_]]
        [[Val] [cast [args[0]] to [Internal_], cast [args[1]] to [Internal_], elem]];
    return make builtin result [cast [func ret] to [args[0].type_]];
}

BuiltinResult#builtin unsafe idx with <[Val]:args> {
    Val:idx = cast [args[1]] to [L_];
    return make builtin result [load [[args[0]].idx[idx]]];
}

BuiltinResult#builtin unsafe int div with <[Val]:args> to <Type_:result_type_> {
    Val:a = cast [args[0]] to [result_type_];
    Val:b = cast [args[1]] to [result_type_];
    return make builtin result [[a] / [b]];
}

BuiltinResult#builtin unsafe idx assign with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    Val:casted = cast [args[2]] to [arr.type_.generics[0]];
    [casted].incr_ref;
    [[arr].idx[idx]] = [casted];
    return make empty builtin result;
}

BuiltinResult#builtin int abs with <[Val]:args> {
    W:bits = (W)args[0].type_.bits;
    Type_:in_type_ = Z_ [bits];
    Type_:result_type_ = W_ [bits];
    extern fn [result_type_] ["llvm.abs.i{}" % bits] [[Type_] [in_type_]]
        [[Val] [cast [args[0]] to [in_type_]]];
    return make builtin result [func ret];
}

BuiltinResult#builtin float abs with <[Val]:args> {
    W:bits = (W)args[0].type_.bits;
    Type_:type_ = Q_ [bits];
    extern fn [type_] ["llvm.fabs.f{}" % bits] [[Type_] [type_]]
        [[Val] [cast [args[0]] to [type_]]];
    return make builtin result [func ret];
}

BuiltinResult#builtin stringify with <[Val]:args> {
    return make builtin result [make stringify of [args[0]]];
}

BuiltinResult#builtin print with <[Val]:args> {
    Val:stringified = make stringify of [args[0]];
    extern fn [null] ["print"] [[Type_] [Str_]] [[Val] [stringified]];
    return make empty builtin result;
}

BuiltinResult#builtin println with <[Val]:args> {
    Val:stringified = make stringify of [args[0]];
    extern fn [null] ["println"] [[Type_] [Str_]] [[Val] [stringified]];
    return make empty builtin result;
}

BuiltinResult#builtin pad left with <[Val]:args> {
    pad array [args[0]] to length [args[1]] with value [args[2]] from left: [true];
    return make empty builtin result;
}

BuiltinResult#builtin pad right with <[Val]:args> {
    pad array [args[0]] to length [args[1]] with value [args[2]] from left: [false];
    return make empty builtin result;
}

BuiltinResult#builtin slice with <[Val]:args> {
    Val:arr = args[0];
    Val:start = cast [args[1]] to [L_];
    Val:end = cast [args[2]] to [L_];
    Val:elem = make elem generic int [arr.type_];
    extern fn [Internal_] ["slice_array"] [[Type_] [Internal_, L_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], start, elem]];
    return make builtin result [cast [func ret] to [arr.type_]];
}

BuiltinResult#builtin count with <[Val]:args> {
    if ([args[0].type_] == [args[1].type_]) {
        return make builtin result [count subarray [args[1]] in [args[0]]];
    } else {
        return make builtin result [count element [args[1]] in [args[0]]];
    };
}

BuiltinResult#builtin overlap count with <[Val]:args> {
    return make builtin result [overlap count subarray [args[1]] in [args[0]]];
}

BuiltinResult#builtin pop end with <[Val]:args> {
    Val:arr = args[0];
    verify array [arr] non empty;
    Val:idx = [load [[arr].length]] - [c L_ [1]];
    Val:elem = load [[arr].idx[idx]];
    [elem].checkless_decr_ref;
    [[arr].length] = [idx];
     // result is not in params when builtin finishes
    return make builtin result [elem];
}

BuiltinResult#builtin nest with <[Val]:args> {
    extern fn [Internal_] ["nest_array"] [[Type_] [Internal_, L_]]
        [[Val] [cast [args[0]] to [Internal_], make elem generic int [args[0].type_]]];
    return make builtin result [cast [func ret] to [Array_ [args[0].type_]]];
}

BuiltinResult#builtin split with <[Val]:args> {
    return make builtin result [split [args[0]] on [args[1]]];
}

BuiltinResult#builtin starts with with <[Val]:args> {
if (specialized fn [Bool_] ["starts_with"] [args]) {
    Val:arr = func arg [0];
    Val:sub = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:sub_len = load [[sub].length];

    if_ [[arr_len] lt [sub_len]];
        ret [c [false]];
    end block;

    ret [buffer eq [[arr].content] to [[sub].content] of len [sub_len]];
end fn;
};
    return make builtin result [func ret];
}

BuiltinResult#builtin ends with with <[Val]:args> {
if (specialized fn [Bool_] ["ends_with"] [args]) {
    Val:arr = func arg [0];
    Val:sub = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:sub_len = load [[sub].length];

    if_ [[arr_len] lt [sub_len]];
        ret [c [false]];
    end block;

    Val:arr_buffer = [[arr].content] shifted by [[arr_len] - [sub_len]];
    ret [buffer eq [arr_buffer] to [[sub].content] of len [sub_len]];
end fn;
};
    return make builtin result [func ret];
}

BuiltinResult#builtin equals with <[Val]:args> deep: <Bool:deep> invert: <Bool:invert> {
    return make builtin result [
        do [args[0]] equals [args[1]] deep: [deep] invert: [invert]
    ];
}

BuiltinResult#builtin join with <[Val]:args> {
    Type_:result_type_ = args[1].type_;
    Val:arr = cast [args[0]] to [Internal_];
    Val:sep = cast [args[1]] to [Internal_];
    extern fn [Internal_] ["join_array"] [[Type_] [Internal_, Internal_, L_]]
        [[Val] [arr, sep, make elem generic int [result_type_]]];
    return make builtin result [cast [func ret] to [result_type_]];
}

BuiltinResult#builtin index of with <[Val]:args> {
    if ([args[0].type_] == [args[1].type_]) {
        return make builtin result [index of subarray [args[1]] in [args[0]]];
    } else {
        return make builtin result [index of elem [args[1]] in [args[0]]];
    };
}

BuiltinResult#builtin parse int with <[Val]:args> {
    extern fn [Z_] ["parse_int"] [[Type_] [Str_]] [args];
    return make builtin result [func ret];
}

BuiltinResult#builtin invalid parsed int {
    extern fn [Z_] ["get_magic_invalid_parsed_int"] [[Type_] []] [[Val] []];
    return make builtin result [func ret];
}

BuiltinResult#builtin parse float with <[Val]:args> {
    extern fn [Q_] ["parse_float"] [[Type_] [Str_]] [args];
    return make builtin result [func ret];
}

BuiltinResult#builtin is_NaN with <[Val]:args> {
    return make builtin result [is_NaN[args[0]]];
}

BuiltinResult#builtin read input line {
    extern fn [Str_] ["read_input_line"] [[Type_] []] [[Val] []];
    return make builtin result [func ret];
}

BuiltinResult#builtin is null_ with <[Val]:args> {
    return make builtin result [[args[0]] == null_];
}

BuiltinResult#builtin unwrap with <[Val]:args> {
    verify [args[0]] is not null_;
    Val:result = bitcast [args[0]] to [unwrap nullability [args[0]]];
    return make builtin result [result] is params;
}

BuiltinResult#dispatch builtin <Str:func_id> with args <[Val]:args> to <Type_?:result_type_> {
    if ([func_id] equals ["builtin1"]) {
        return builtin length with [args];
    } elif ([func_id] equals ["builtin2"]) {
        return builtin capacity with [args];
    } elif ([func_id] equals ["builtin3"]) {
        return builtin append with [args];
    } elif ([func_id] equals ["builtin4"]) {
        return builtin require capacity with [args];
    } elif ([func_id] equals ["builtin5"]) {
        return builtin shrink mem with [args];
    } elif ([func_id] equals ["builtin6"]) {
        return builtin pop with [args];
    } elif ([func_id] equals ["builtin7"]) {
        return builtin insert with [args];
    } elif ([func_id] equals ["builtin8"]) {
        return builtin clone with [args];
    } elif ([func_id] equals ["builtin9"]) {
        return builtin extend with [args];
    } elif ([func_id] equals ["builtin10"]) {
        return builtin concat with [args];
    } elif ([func_id] equals ["builtin11"]) {
        return builtin unsafe idx with [args];
    } elif ([func_id] equals ["builtin12"]) {
        return builtin unsafe int div with [args] to [[result_type_].unwrap];
    } elif ([func_id] equals ["builtin13"]) {
        return builtin unsafe idx assign with [args];
    } elif ([func_id] equals ["builtin14"]) {
        return builtin int abs with [args];
    } elif ([func_id] equals ["builtin15"]) {
        return builtin float abs with [args];
    } elif ([func_id] equals ["builtin16"]) {
        return builtin concat with [args];
    } elif ([func_id] equals ["builtin17"]) {
        return builtin stringify with [args];
    } elif ([func_id] equals ["builtin18"]) {
        return builtin print with [args];
    } elif ([func_id] equals ["builtin19"]) {
        return builtin println with [args];
    } elif ([func_id] equals ["builtin20"]) {
        return builtin pad left with [args];
    } elif ([func_id] equals ["builtin21"]) {
        return builtin pad right with [args];
    } elif ([func_id] equals ["builtin22"]) {
        return builtin slice with [args];
    } elif ([func_id] equals ["builtin23"]) {
        return builtin count with [args];
    } elif ([func_id] equals ["builtin24"]) {
        return builtin overlap count with [args];
    } elif ([func_id] equals ["builtin25"]) {
        return builtin pop end with [args];
    } elif ([func_id] equals ["builtin26"]) {
        return builtin nest with [args];
    } elif ([func_id] equals ["builtin27"]) {
        return builtin split with [args];
    } elif ([func_id] equals ["builtin28"]) {
        return builtin starts with with [args];
    } elif ([func_id] equals ["builtin29"]) {
        return builtin ends with with [args];
    } elif ([func_id] equals ["builtin30"]) {
        return builtin equals with [args] deep: [false] invert: [false];
    } elif ([func_id] equals ["builtin31"]) {
        return builtin equals with [args] deep: [false] invert: [true];
    } elif ([func_id] equals ["builtin32"]) {
        return builtin equals with [args] deep: [true] invert: [false];
    } elif ([func_id] equals ["builtin33"]) {
        return builtin equals with [args] deep: [true] invert: [true];
    } elif ([func_id] equals ["builtin34"]) {
        return builtin join with [args];
    } elif ([func_id] equals ["builtin35"]) {
        return builtin index of with [args];
    } elif ([func_id] equals ["builtin36"]) {
        return builtin parse int with [args];
    } elif ([func_id] equals ["builtin37"]) {
        return builtin invalid parsed int;
    } elif ([func_id] equals ["builtin38"]) {
        return builtin parse float with [args];
    } elif ([func_id] equals ["builtin39"]) {
        return builtin is_NaN with [args];
    } elif ([func_id] equals ["builtin40"]) {
        return builtin read input line;
    } elif ([func_id] equals ["builtin41"]) {
        return builtin is null_ with [args];
    } elif ([func_id] equals ["builtin41"]) {
        return builtin is null_ with [args];
    } elif ([func_id] equals ["builtin42"]) {
        return builtin unwrap with [args];
    } else {
        abort "Builtin {} does not exist or is not implemented" % func_id;
    };
}

Val?#call builtin <Str:func_id> with args <[Val]:args> to <Type_?:result_type_> {
    BuiltinResult:result = dispatch builtin [func_id] with args [args] to [result_type_];

    if (!result.result_is_params) {
        if (result.result_in_params) {
            [[result.result].unwrap].incr_ref;
        };
        for (Val:arg in args) {
            [arg].check_ref;
        };
        if (result.result_in_params) {
            [[result.result].unwrap].checkless_decr_ref;
        };
    };

    return result.result;
}
