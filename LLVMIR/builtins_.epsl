#import operations;
#import stringify;
#import eewriter;


BuiltinResult {
    Val?:result,
    Bool:result_in_params,
    Bool:result_is_params
}

BuiltinResult#make builtin result <Val:result> {
    return BuiltinResult [result, false, false];
}

BuiltinResult#make builtin result <Val:result> in params {
    return BuiltinResult [result, true, false];
}

BuiltinResult#make empty builtin result {
    return BuiltinResult [null, false, false];
}

BuiltinResult#builtin length with <[Val]:args> {
    return make builtin result [load [[args[0]].length]];
}

BuiltinResult#builtin capacity with <[Val]:args> {
    return make builtin result [load [[args[0]].capacity]];
}

BuiltinResult#builtin append with <[Val]:args> {
    Val:arr = args[0];
    Type_:generic = arr.type_.generics[0];
    Val:appendee = cast [args[1]] to [generic];
    Val:len = load [[arr].length];
    extern fn [null] ["increment_length"] [[Type_] [Internal_, L_]]
        [[Val] [cast [arr] to [Internal_], make elem int [generic]]];
    [[load [[arr].content]].idx[len]] = [appendee];
    [appendee].incr_ref;
    return make empty builtin result;
}

BuiltinResult#builtin require capacity with <[Val]:args> {
    Val:arr = args[0];
    Val:required_cap = cast [args[1]] to [L_];
    extern fn [null] ["require_capacity"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], required_cap, sizeof elem [arr.type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin shrink mem with <[Val]:args> {
    Val:arr = args[0];
    extern fn [null] ["shrink_mem"] [[Type_] [Internal_, L_]]
        [[Val] [cast [arr] to [Internal_], sizeof elem [arr.type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin pop with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    verify idx [idx] in array [arr];
    Val:elem = load [[arr].idx[idx]];
    [elem].checkless_decr_ref;
    extern fn [null] ["remove_at"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], idx, sizeof [elem.type_]]];
    return make builtin result [elem]; // result is not in params when builtin finishes
}

BuiltinResult#builtin insert with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    Type_:generic = arr.type_.generics[0];
    Val:elem = cast [args[2]] to [generic];
    extern fn [null] ["insert_space"] [[Type_] [Internal_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], idx, sizeof [generic]]];
    [elem].incr_ref;
    [[arr].idx[idx]] = [elem];
    return make empty builtin result;
}

BuiltinResult#builtin clone with <[Val]:args> {
    return make builtin result [[args[0]].clone];
}

BuiltinResult#builtin extend with <[Val]:args> {
    Val:arr1 = cast [args[0]] to [Internal_];
    Val:arr2 = cast [args[1]] to [Internal_];
    assert type_ equality [args[0]], [args[1]];
    extern fn [null] ["extend_array"] [[Type_] [Internal_, Internal_, L_]]
        [[Val] [arr1, arr2, make elem generic int [args[0].type_]]];
    return make empty builtin result;
}

BuiltinResult#builtin concat with <[Val]:args> {
    assert type_ equality [args[0]], [args[1]];
    Val:elem = make elem generic int [args[0].type_];
    extern fn [Internal_] ["concat_arrays"] [[Type_] [Internal_, Internal_, L_]]
        [[Val] [cast [args[0]] to [Internal_], cast [args[1]] to [Internal_], elem]];
    return make builtin result [cast [func ret] to [args[0].type_]];
}

BuiltinResult#builtin unsafe idx with <[Val]:args> {
    Val:idx = cast [args[1]] to [L_];
    return make builtin result [load [[args[0]].idx[idx]]];
}

BuiltinResult#builtin unsafe int div with <[Val]:args> to <Type_:result_type_> {
    Val:a = cast [args[0]] to [result_type_];
    Val:b = cast [args[1]] to [result_type_];
    return make builtin result [[a] / [b]];
}

BuiltinResult#builtin unsafe idx assign with <[Val]:args> {
    Val:arr = args[0];
    Val:idx = cast [args[1]] to [L_];
    Val:casted = cast [args[2]] to [arr.type_.generics[0]];
    [casted].incr_ref;
    [[arr].idx[idx]] = [casted];
    return make empty builtin result;
}

BuiltinResult#builtin int abs with <[Val]:args> {
    W:bits = (W)args[0].type_.bits;
    Type_:in_type_ = Z_ [bits];
    Type_:result_type_ = W_ [bits];
    extern fn [result_type_] ["llvm.abs.i{}" % bits] [[Type_] [in_type_]]
        [[Val] [cast [args[0]] to [in_type_]]];
    return make builtin result [func ret];
}

BuiltinResult#builtin float abs with <[Val]:args> {
    W:bits = (W)args[0].type_.bits;
    Type_:type_ = Q_ [bits];
    extern fn [type_] ["llvm.fabs.f{}" % bits] [[Type_] [type_]]
        [[Val] [cast [args[0]] to [type_]]];
    return make builtin result [func ret];
}

BuiltinResult#builtin stringify with <[Val]:args> {
    return make builtin result [make stringify of [args[0]]];
}

BuiltinResult#builtin print with <[Val]:args> {
    Val:stringified = make stringify of [args[0]];
    extern fn [null] ["print"] [[Type_] [Str_]] [[Val] [stringified]];
    return make empty builtin result;
}

BuiltinResult#builtin println with <[Val]:args> {
    Val:stringified = make stringify of [args[0]];
    extern fn [null] ["println"] [[Type_] [Str_]] [[Val] [stringified]];
    return make empty builtin result;
}

BuiltinResult#builtin pad left with <[Val]:args> {
    pad array [args[0]] to length [args[1]] with value [args[2]] from left: [true];
    return make empty builtin result;
}

BuiltinResult#builtin pad right with <[Val]:args> {
    pad array [args[0]] to length [args[1]] with value [args[2]] from left: [false];
    return make empty builtin result;
}

BuiltinResult#builtin slice with <[Val]:args> {
    Val:arr = args[0];
    Val:start = cast [args[1]] to [L_];
    Val:end = cast [args[2]] to [L_];
    Val:elem = make elem generic int [arr.type_];
    extern fn [Internal_] ["slice_array"] [[Type_] [Internal_, L_, L_, L_]]
        [[Val] [cast [arr] to [Internal_], start, elem]];
    return make builtin result [cast [func ret] to [arr.type_]];
}

BuiltinResult#builtin count with <[Val]:args> {
    Type_:generic = args[0].type_.generics[0];
if (specialized fn [L_] ["count"] [[Val] [args[0], cast [args[1]] to [generic]]]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];
Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] lt [arr_len]] from [check_label];
        if_ [[[arr].idx[cur_i]] eq [target]];
            [count] = [[count] + [c L_ [1]]];
        end block;
        [i] = [[cur_i] + [c L_ [1]]];
    end block;
    ret [count];
end fn;
};
    return make builtin result [func ret];
}

BuiltinResult#builtin count subarray with <[Val]:args> {
if (specialized fn [L_] ["count_subarray"] [args]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:target_len = load [[target].length];
    Val:i_to = [arr_len] - [target_len];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];
    Val:j = var [L_];
Label:check_label_1 = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label_1];
        Block:loop_1 = current block;
        [j] = [c L_ [0]];
    Label:check_label_2 = new label:;
        Val:cur_j = load [j];
        while_ [[cur_j] lt [target_len]] from [check_label_2];
            if_ [[[arr].idx[[cur_i] + [cur_j]]] ne [[target].idx[cur_j]]];
                [i] = [[cur_i] + [c L_ [1]]];
                continue_ [loop_1];
            end block;
            [j] = [[cur_j] + [c L_ [1]]];
        end block;
        [count] = [[count] + [c L_ [1]]];
        [i] = [[cur_i] + [target_len]];
    end block;
    ret [count];
end fn;
};
    return make builtin result [func ret];
}

BuiltinResult#builtin overlap count subarray with <[Val]:args> {
if (specialized fn [L_] ["overlap_count_subarray"] [args]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:target_len = load [[target].length];
    Val:i_to = [arr_len] - [target_len];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];
    Val:j = var [L_];
Label:check_label_1 = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label_1];
        Block:loop_1 = current block;
        [i] = [[cur_i] + [c L_ [1]]];
        [j] = [c L_ [0]];
    Label:check_label_2 = new label:;
        Val:cur_j = load [j];
        while_ [[cur_j] lt [target_len]] from [check_label_2];
            if_ [[[arr].idx[[cur_i] + [cur_j]]] ne [[target].idx[cur_j]]];
                continue_ [loop_1];
            end block;
            [j] = [[cur_j] + [c L_ [1]]];
        end block;
        [count] = [[count] + [c L_ [1]]];
    end block;
    ret [count];
end fn;
};
    return make builtin result [func ret];
}

BuiltinResult#builtin nest with <[Val]:args> {
    extern fn [Internal_] ["nest_array"] [[Type_] [Internal_, L_]]
        [[Val] [cast [args[0]] to [Internal_], make elem generic int [args[0].type_]]];
    return make builtin result [cast [func ret] to [Array_ [args[0].type_]]];
}

BuiltinResult#builtin split with <[Val]:args> {
    return make builtin result [split [args[0]] on [args[1]]];
}

BuiltinResult#dispatch builtin <Str:func_id> with args <[Val]:args> to <Type_?:result_type_> {
    if ([func_id] equals ["builtin1"]) {
        return builtin length with [args];
    } elif ([func_id] equals ["builtin2"]) {
        return builtin capacity with [args];
    } elif ([func_id] equals ["builtin3"]) {
        return builtin append with [args];
    } elif ([func_id] equals ["builtin4"]) {
        return builtin require capacity with [args];
    } elif ([func_id] equals ["builtin5"]) {
        return builtin shrink mem with [args];
    } elif ([func_id] equals ["builtin6"]) {
        return builtin pop with [args];
    } elif ([func_id] equals ["builtin7"]) {
        return builtin insert with [args];
    } elif ([func_id] equals ["builtin8"]) {
        return builtin clone with [args];
    } elif ([func_id] equals ["builtin9"]) {
        return builtin extend with [args];
    } elif ([func_id] equals ["builtin10"]) {
        return builtin concat with [args];
    } elif ([func_id] equals ["builtin11"]) {
        return builtin unsafe idx with [args];
    } elif ([func_id] equals ["builtin12"]) {
        return builtin unsafe int div with [args] to [[result_type_].unwrap];
    } elif ([func_id] equals ["builtin13"]) {
        return builtin unsafe idx assign with [args];
    } elif ([func_id] equals ["builtin14"]) {
        return builtin int abs with [args];
    } elif ([func_id] equals ["builtin15"]) {
        return builtin float abs with [args];
    } elif ([func_id] equals ["builtin16"]) {
        return builtin concat with [args];
    } elif ([func_id] equals ["builtin17"]) {
        return builtin stringify with [args];
    } elif ([func_id] equals ["builtin18"]) {
        return builtin print with [args];
    } elif ([func_id] equals ["builtin19"]) {
        return builtin println with [args];
    } elif ([func_id] equals ["builtin20"]) {
        return builtin pad left with [args];
    } elif ([func_id] equals ["builtin21"]) {
        return builtin pad right with [args];
    } elif ([func_id] equals ["builtin22"]) {
        return builtin slice with [args];
    } elif ([func_id] equals ["builtin23"]) {
        return builtin count with [args];
    } elif ([func_id] equals ["builtin24"]) {
        return builtin count subarray with [args];
    } elif ([func_id] equals ["builtin25"]) {
        return builtin overlap count subarray with [args];
    } elif ([func_id] equals ["builtin26"]) {
        return builtin nest with [args];
    } elif ([func_id] equals ["builtin27"]) {
        return builtin split with [args];
    } else {
        abort "Builtin {} does not exist or is not implemented" % func_id;
    };
}

Val?#call builtin <Str:func_id> with args <[Val]:args> to <Type_?:result_type_> {
    BuiltinResult:result = dispatch builtin [func_id] with args [args] to [result_type_];

    if (!result.result_is_params) {
        if (result.result_in_params) {
            [[result.result].unwrap].incr_ref;
        };
        for (Val:arg in args) {
            [arg].check_ref;
        };
        if (result.result_in_params) {
            [[result.result].unwrap].checkless_decr_ref;
        };
    };

    return result.result;
}
