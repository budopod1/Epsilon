#import entry;
#import eewriter;
#import binjson;
#import builtins_;

[Val]#cast <[Val]:vals> to <Type_:type_> {
    [Val]:result = [Val] [];
    for (Val:val in vals) {
        [result].append[cast [val] to [type_]];
    };
    return result;
}

#div zero error {
    extern fn [null] ["div_0_fail"] [[Type_] []] [[Val] []];
}

Val#safe <Val:a> / <Val:b> {
    assert type_ equality [a], [b];
    if (![a.type_].is_float) {
        if_ [[b] eq [c [0] [b.type_]]];
            div zero error;
        end block;
    };
    return [a] / [b];
}

Val#safe <Val:a> % <Val:b> {
    assert type_ equality [a], [b];
    if (![a.type_].is_float) {
        if_ [[b] eq [c [0] [b.type_]]];
            div zero error;
        end block;
    };
    return [a] % [b];
}

Val#do chain power of <Val:base> to the <Z:exponent> {
    if (exponent == 0) {
        return c [1] [base.type_];
    } elif (exponent == 1) {
        return base;
    } elif (exponent < 0) {
        return safe [c [1] [base.type_]] / [do chain power of [base] to the [-exponent]];
    } elif (exponent % 2 == 0) {
        Val:factor = do chain power of [base] to the [exponent ~/ 2];
        return [factor] * [factor];
    } else {
        return [do chain power of [base] to the [exponent - 1]] * [base];
    };
}

Val#integer <Val:base_in> to the <Val:exponent_in> {
    Type_:base_type_ = base_in.type_;
    Type_:exponent_type_ = exponent_in.type_;

if (specialized fn [base_type_] ["integer_exponent"] [[Val] [base_in, exponent_in]]) {
    Val:base = var [base_type_] [func arg [0]];
    Val:exponent = var [exponent_type_] [func arg [1]];
    Val:result = var [base_type_] [c [1] [base_type_]];

    Label:loop = new label:;
        Val:exponent_here = load [exponent];
        Val:exponent_1 = c [1] [exponent_type_];
        Val:base_here = load [base];
        if_ [[[exponent_here] AND [exponent_1]].truth_value];
            [result] = [[result] * [base_here]];
        end block;
        Val:exponent_new = [exponent_here] shift right [exponent_1];
        [exponent] = [exponent_new];
        if_ [[exponent_new].untruth_value];
            ret [result];
        end block;
        [base] = [[base_here] * [base_here]];
    goto_ [loop];
end fn;
};
    return func ret;
}

Val#consume truth <Val:val> {
    Val:truth = [val].truth_value;
    [truth].check_ref;
    return truth;
}

#verify idx <Val:idx> in array <Val:arr> {
    if_ [expect [[cast [idx] to [L_]] ge [[arr].length]] to be [false]];
        extern fn [null] ["array_idx_fail"] [[Type_] []] [[Val] []];
        mark as unreachable;
    end block;
}

Val#make elem int <Type_:type_> {
    Val:result = [sizeof [type_]] * [c L_ [4]];
    if (![type_].is_ref) {
        result = [result] + [c L_ [2]];
    };
    if ([type_].is_nullable) {
        result = [result] + [c L_ [1]];
    };
    return result;
}

Val#make elem generic int <Type_:type_> {
    if ([type_.generics].len == 0) {
        abort "Cannot make elem generic int of type_ {}, as it has no generics" % [type_].stringify;
    };
    return make elem int [type_.generics[0]];
}

Val#make constant <BinJSON:constant_json> of type_ <Type_:type_> {
    BinJSON:val_json = [constant_json].get["value"];
    Str:constant_type = [[constant_json].get["type"]].get_str;
    if (([constant_type] equals ["int"]) || ([constant_type] equals ["uint"])) {
        return c [[val_json].get_int] [type_];
    } elif ([constant_type] equals ["bool"]) {
        return c [(Z)[val_json].get_bool] [type_];
    } elif ([constant_type] equals ["float-standard"]) {
        return c [[val_json].get_double] [type_];
    } elif ([constant_type] equals ["float-special"]) {
        Q:val = NaN;
        Str:val_str = [val_json].get_str;
        if ([val_str] equals ["+Infinity"]) {
            val = infinity;
        } elif ([val_str] equals ["-Infinity"]) {
            val = -infinity;
        } elif ([val_str] equals ["NaN"]) {
            val = NaN;
        } else {
            abort "Unknown special float type {}" % val_str;
        };
        return c [val] [type_];
    };
    abort "Unknown constant type {}" % constant_type;
}

Val#<Val:val>.clone {
    Type_:type_ = val.type_;
    if ([type_.name] equals ["Array"]) {
        extern fn [Internal_] ["clone_array"] [[Type_] [Internal_, L_]]
            [[Val] [cast [val] to [Internal_], make elem generic int [type_]]];
        return cast [func ret] to [type_];
    };
    abort "Clone operation not yet implemented on type_ {}" % [type_].stringify;
}

Bool#is builtin func id <Str:func_id> {
    return [func_id].starts_with["builtin"];
}

Val?#call nonbuiltin function <Str:func_id> with args <[Val]:args> {
    FuncProto:proto = get func proto [func_id];

    [Val]:casted_args = [Val] [];
    for (L:i enumerating args) {
        [casted_args].append[cast [args[i]] to [proto.arg_types_[i]]];
    };

    Type_?:ret_type_ = proto.ret_type_;
    extern fn [ret_type_] [proto.callee] [proto.arg_types_] [casted_args];

    Val?:return_val = null;
    if (ret_type_) {
        return_val = func ret;
    };

    if (proto.takes_ownership) {
        if (proto.result_in_params && ![return_val].is_null) {
            [[return_val].unwrap].incr_ref;
        };

        for (Val:arg in args) {
            [arg].check_ref;
        };

        if (proto.result_in_params && ![return_val].is_null) {
            [[return_val].unwrap].checkless_decr_ref;
        };
    };

    return return_val;
}

Val?#call function <Str:func_id> with args <[Val]:args> to <Type_?:result_type_> {
    if (is builtin func id [func_id]) {
        return call builtin [func_id] with args [args] to [result_type_];
    } else {
        return call nonbuiltin function [func_id] with args [args];
    };
}

#verify array <Val:arr> non empty {
    if_ [expect [[c L_ [0]] eq [[arr].length]] to be [false]];
        extern fn [null] ["array_empty_fail"] [[Type_] []] [[Val] []];
        mark as unreachable;
    end block;
}

#pad array <Val:outer_arr> to length <Val:outer_len> with value <Val:outer_val> from left: <Bool:pad_left> {
    Str:name = "pad_right";
    if (pad_left) {
        name = "pad_left";
    };

if (specialized fn [null] [name] [[Val] [outer_arr, outer_len, outer_val]]) {
    Val:arr = func arg [0];
    Type_:generic = arr.type_.generics[0];
    Val:len = cast [func arg [1]] to [L_];
    Val:val = cast [func arg [2]] to [generic];

    Val:cur_len = load [[arr].length];

    if_ [[cur_len] lt [len]];
        extern fn [null] ["require_capacity"] [[Type_] [Internal_, L_, L_]]
            [[Val] [cast [arr] to [Internal_], len, sizeof elem [arr.type_]]];

        Val:content = load [[arr].content];

        [[arr].length] = [len];

        Val:fill_amount = [len] - [cur_len];

        if (pad_left) {
            Val:content_dest = [content] shifted by [fill_amount];
            extern fn [null] ["memmove"] [[Type_] [Pointer [Byte_], Pointer [Byte_], L_]]
                [[Val] [content_dest, content, cur_len]];
        };

        if ([generic] == [Byte_]) {
            Val?:pad_dest = null;
            if (pad_left) {
                pad_dest = content;
            } else {
                pad_dest = [content] shifted by [cur_len];
            };

            extern fn [null] ["memset"] [[Type_] [Pointer [Byte_], Z_, L_]]
                [[Val] [[pad_dest].unwrap, cast [val] to [Z_], fill_amount]];
        } else {
            Val?:from = null;
            Val?:to = null;
            if (pad_left) {
                from = c L_ [0];
                to = fill_amount;
            } else {
                from = cur_len;
                to = len;
            };

            Val:i = var [[from].unwrap];
        Label:check_label = new label:;
            Val:i_now = load [i];
            while_ [[i_now] lt [[to].unwrap]] from [check_label];
                [[content].idx[i_now]] = [val];
                [val].incr_ref;
                [i] = [[i_now] + [c L_ [1]]];
            end block;
        };
    end block;

    ret void;
end fn;
};
}

Val#buffer eq <Val:outer_a> to <Val:outer_b> of len <Val:outer_len> {
    assert type_ equality [outer_a], [outer_b];
    Type_:generic = outer_a.type_.generics[0];
    outer_len = cast [outer_len] to [L_];

    if ([generic] == [Byte_]) {
        extern fn [Z_] ["memcmp"] [[Type_] [Pointer [Byte_], Pointer [Byte_], L_]]
            [[Val] [outer_a, outer_b, outer_len]];
        return [func ret] eq [c [(Z)0]];
    };

if (specialized fn [Bool_] ["buffer_cmp"] [[Val] [outer_a, outer_b, outer_len]]) {
    Val:a = func arg [0];
    Val:b = func arg [1];
    Val:len = func arg [2];

    Val:i = var [c L_ [0]];
Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] lt [len]] from [check_label];
        if_ [[[a].idx[cur_i]] ne [[b].idx[cur_i]]];
            ret [c [false]];
        end block;
        [i] = [[cur_i] + [c L_ [1]]];
    end block;

    ret [c [true]];
end fn;
};

    return func ret;
}

Val#count element <Val:outer_elem> in <Val:outer_arr> {
    Type_:generic = outer_arr.type_.generics[0];
    Val:casted_elem = cast [outer_elem] to [generic];
if (specialized fn [L_] ["count"] [[Val] [outer_arr, casted_elem]]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];
Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] lt [arr_len]] from [check_label];
        if_ [[[arr].idx[cur_i]] eq [target]];
            [count] = [[count] + [c L_ [1]]];
        end block;
        [i] = [[cur_i] + [c L_ [1]]];
    end block;
    ret [count];
end fn;
};
    return func ret;
}

Val#count subarray <Val:outer_subarray> in <Val:outer_arr> {
    assert type_ equality [outer_arr], [outer_subarray];
if (specialized fn [L_] ["count_subarray"] [[Val] [outer_arr, outer_subarray]]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:target_len = load [[target].length];
    if_ [[target_len] gt [arr_len]];
        ret [c L_ [0]];
    end block;

    Val:i_to = [arr_len] - [target_len];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];

Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label];
        Block:loop = current block;

        Val:arr_buffer = [[arr].content] shifted by [cur_i];
        if_ [buffer eq [arr_buffer] to [[target].content] of len [target_len]];
            [count] = [[count] + [c L_ [1]]];
            [i] = [[cur_i] + [target_len]];
            continue_ [loop];
        end block;

        [i] = [[cur_i] + [c L_ [1]]];
    end block;
    ret [count];
end fn;
};
    return func ret;
}

Val#overlap count subarray <Val:outer_subarray> in <Val:outer_arr> {
if (specialized fn [L_] ["overlap_count_subarray"] [[Val] [outer_arr, outer_subarray]]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];
    Val:arr_len = load [[arr].length];
    Val:target_len = load [[target].length];
    if_ [[target_len] gt [arr_len]];
        ret [c L_ [0]];
    end block;

    Val:i_to = [arr_len] - [target_len];
    Val:count = var [c L_ [0]];
    Val:i = var [c L_ [0]];

Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label];
        Val:arr_buffer = [[arr].content] shifted by [cur_i];
        if_ [buffer eq [arr_buffer] to [[target].content] of len [target_len]];
            [count] = [[count] + [c L_ [1]]];
        end block;

        [i] = [[cur_i] + [c L_ [1]]];
    end block;
    ret [count];
end fn;
};
    return func ret;
}

#add split segment of type_ <Type_:arr_type_> from <Val:part_start> to <Val:cur_i> sourced from <Val:arr_content> to <Val:result> {
    Type_:generic = arr_type_.generics[0];

    part_start = load [part_start];

    Val:part_len = [cur_i] - [part_start];
    Val:part = malloc pointee [arr_type_];
    [[part].ref] = [c L_ [1]];
    Val:part_cap = [[part_len] eq [c L_ [0]]] ? [c L_ [1]] : [part_len];
    [[part].capacity] = [part_cap];
    [[part].length] = [part_len];

    Val:part_content = malloc [part_cap] [generic];
    memcpy [part_len] [[arr_content] shifted by [part_start]] to [part_content];
    [[part].content] = [part_content];

    extern fn [null] ["increment_array_ref_counts"] [[Type_] [Internal_, L_]]
        [[Val] [cast [part] to [Internal_], make elem int [generic]]];

    Val:part_idx = load [[result].length];
    extern fn [null] ["increment_length"] [[Type_] [Internal_, L_]]
        [[Val] [cast [result] to [Internal_], make elem int [arr_type_]]];
    [[result].idx[part_idx]] = [part];
}

Val#split <Val:outer_arr> on <Val:outer_sep> {
    Type_:arr_type_ = outer_arr.type_;
    Type_:generic = arr_type_.generics[0];
    Type_:result_type_ = Array_ [arr_type_];
if (specialized fn [result_type_] ["split"] [[Val] [outer_arr, outer_sep]]) {
    Val:arr = func arg [0];
    Val:arr_len = load [[arr].length];
    Val:arr_content = load [[arr].content];
    Val:sep = func arg [1];
    Val:sep_len = load [[sep].length];
    Val:result = new array [result_type_] [[Val] []] with capacity [3];
    Val:part_start = var [c L_ [0]];
    Val:i_to = [arr_len] - [sep_len];

    Val:i = var [c L_ [0]];
Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label];
        Block:loop = current block;

        Val:arr_buffer = [[arr].content] shifted by [cur_i];
        if_ [buffer eq [arr_buffer] to [[sep].content] of len [sep_len]];
            add split segment of type_ [arr_type_] from [part_start] to [cur_i]
            sourced from [arr_content] to [result];

            Val:new_i = [cur_i] + [sep_len];
            [i] = [new_i];
            [part_start] = [new_i];
            continue_ [loop];
        end block;

        [i] = [[cur_i] + [c L_ [1]]];
    end block;

    add split segment of type_ [arr_type_] from [part_start] to [arr_len]
        sourced from [arr_content] to [result];

    ret [result];
end fn;
};

    return func ret;
}

Val#index of elem <Val:outer_elem> in <Val:outer_arr> {
    Type_:elem_type_ = outer_arr.type_.generics[0];
    outer_elem = cast [outer_elem] to [elem_type_];

if (specialized fn [Z_ [64]] ["index_of_elem"] [[Val] [outer_arr, outer_elem]]) {
    Val:arr = func arg [0];
    Val:target = func arg [1];

    Val:arr_len = load [[arr].length];
    Val:i = var [c [0] [Z_ [64]]];

Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] lt [cast [arr_len] to [Z_ [64]]]] from [check_label];
        Val:elem = [arr].idx[cur_i];
        if_ [[elem] eq [target]];
            ret [cur_i];
        end block;
        [i] = [[cur_i] + [c [1] [Z_ [64]]]];
    end block;

    ret [c [-1] [Z_ [64]]];
end fn;
};

    return func ret;
}

Val#index of subarray <Val:outer_subarray> in <Val:outer_arr> {
if (specialized fn [Z_ [64]] ["index_of_subarray"] [[Val] [outer_arr, outer_subarray]]) {
    Val:arr = func arg [0];
    Val:subarray = func arg [1];

    Val:arr_len = load [[arr].length];
    Val:arr_content = load [[arr].content];
    Val:subarray_len = load [[subarray].length];
    Val:subarray_content = load [[subarray].content];
    Val:i = var [c [0] [Z_ [64]]];
    Val:i_to = cast [[arr_len] - [subarray_len]] to [Z_ [64]];

Label:check_label = new label:;
    Val:cur_i = load [i];
    while_ [[cur_i] le [i_to]] from [check_label];
        Val:arr_buffer = [arr_content] shifted by [cur_i];
        if_ [buffer eq [arr_buffer] to [subarray_content] of len [subarray_len]];
            ret [cur_i];
        end block;
        [i] = [[cur_i] + [c [1] [Z_ [64]]]];
    end block;

    ret [c [-1] [Z_ [64]]];
end fn;
};

    return func ret;
}

#verify <Val:val> is not null_ {
    if_ [expect [[val] == null_] to be [false]];
        extern fn [null] ["null_value_fail"] [[Type_] []] [[Val] []];
        mark as unreachable;
    end block;
}

Val#make compare func of <Type_:type_> invert: <Bool:invert> {
    Type_:ptr_type_ = Pointer [type_];
    Str:name = "compare_ptrs";
    if (invert) {
        name = "invert_compare_ptrs";
    };
if (specialized fn [Z_] [name] [[Type_] [ptr_type_, ptr_type_]]) {
    Val:a = load [*[func arg [invert]]];
    Val:b = load [*[func arg [1-invert]]];
    ret [[cast [[a] gt [b]] to [Z_]] - [cast [[b] gt [a]] to [Z_]]];
end fn;
};

    return func ptr;
}

Val#sort array <Val:arr> invert: <Bool:invert> {
    Type_:compar_type_ = FuncPtr [Z_] [[Type_] [Internal_, Internal_]];
    Val:compar = make compare func of [arr.type_.generics[0]] invert: [invert];
    compar = cast [compar] to [compar_type_];
    extern fn [null] ["qsort"] [[Type_] [Internal_, L_, L_, compar_type_]]
        [[Val] [cast [[arr].content] to [Internal_], [arr].length, sizeof elem [arr.type_], compar]];
    return func ret;
}
